[{"data":1,"prerenderedAt":826},["ShallowReactive",2],{"navigation":3,"/maps/_fe-framework/ui/vue":161,"/maps/_fe-framework/ui/vue-surround":817},[4,35,92,98,125,131,155],{"title":5,"_path":6,"children":7},"心流思绪 / Heart Flows","/flows",[8,11,14,17,20,23,26,29,32],{"title":9,"_path":10},"📕 狮子的书单推荐","/flows/books",{"title":12,"_path":13},"🚝 四十二篇系列","/flows/fourty-two",{"title":15,"_path":16},"🌃 长夜梦","/flows/long-night-dream",{"title":18,"_path":19},"🌌 万物联结与幸福感","/flows/everything",{"title":21,"_path":22},"⌛ 偷取时间","/flows/stealing-time-from-god",{"title":24,"_path":25},"🌆 表达和孤独","/flows/expression-and-loneliness",{"title":27,"_path":28},"🌧️ 我的腼腆","/flows/shy",{"title":30,"_path":31},"🥛 新工作，喝新饮料","/flows/drinking-while-thinking",{"title":33,"_path":34},"📝 心流归档","/flows/archive",{"title":36,"_path":37,"children":38},"技术博客 / Coder","/articles",[39,41,44,47,50,53,56,59,62,65,68,71,74,77,80,83,86,89],{"title":40,"_path":37},"🦁 欢迎",{"title":42,"_path":43},"🖌️ Blockies Animation","/maps/_fe-framework/motion/blockies-animation",{"title":45,"_path":46},"🌪️ Tailwind v4 如何兼容预处理器","/articles/tailwind4-with-sass",{"title":48,"_path":49},"🥞 在 tailwind 中使用现代化 CSS Layers","/articles/tailwind-sass-and-css-layer",{"title":51,"_path":52},"💻 本地部署 Qwen 翻译网页","/articles/local-translator",{"title":54,"_path":55},"🧊 模板解析器轻考古","/articles/micro-templating",{"title":57,"_path":58},"Ⓜ️ Mini CSS Parser","/articles/mini-css-parser",{"title":60,"_path":61},"🚩 向AI咨询前端问题","/articles/use-gpt-learn-complex-frontend",{"title":63,"_path":64},"⛸️ 怎样定制复杂组件的自定义滚动条？","/articles/use-scrollbars",{"title":66,"_path":67},"⚖️ 统一多组件库的层叠顺序","/articles/zindex-manager",{"title":69,"_path":70},"🕷️ 滑动验证码破解思路","/articles/crack-the-slider",{"title":72,"_path":73},"🌟 探秘 CSS 光影效果","/articles/css-light-travel",{"title":75,"_path":76},"🍲 设计模式与 JS 魔法锅","/articles/design-patterns-and-js-magic-pot",{"title":78,"_path":79},"🌐 Anysort：灵活、优雅的多属性排序","/articles/anysort-2th",{"title":81,"_path":82},"💫 CSS 幻术 | 抗锯齿","/articles/css-poaa",{"title":84,"_path":85},"❓ 用纯CSS判断鼠标进入的方向","/articles/css-judge-direction",{"title":87,"_path":88},"📝 你本可以少写些 if-else","/articles/no-more-if-else",{"title":90,"_path":91},"📝 技术博客归档","/articles/archive",{"title":93,"_path":94,"children":95},"读书笔记 / Notes","/books",[96],{"title":97,"_path":94},"📕 读书笔记",{"title":99,"_path":100,"children":101},"吉他剧场 / Music","/music",[102,104,107,110,113,116,119,122],{"title":103,"_path":100},"🎸 FingerStyle！",{"title":105,"_path":106},"🌬️ 等待的风","/music/wind",{"title":108,"_path":109},"💕 约定的海洋","/music/ocean",{"title":111,"_path":112},"🎼 Wings~You are the Hero！","/music/wings-you-are-the-hero",{"title":114,"_path":115},"🌏 残酷天使的行动纲领","/music/eva",{"title":117,"_path":118},"🏔️ 奇跡の山","/music/miracle-mountain",{"title":120,"_path":121},"🍷 Wu Wei","/music/wu-wei",{"title":123,"_path":124},"🌅 无题","/music/untitled",{"title":126,"_path":127,"children":128},"知识地图 / Maps","/maps",[129],{"title":130,"_path":127},"🏁 知识地图",{"title":132,"_path":133,"children":134},"造物 / Make","/tools",[135,137,140,143,146,149,152],{"title":136,"_path":133},"🧰 工具收集",{"title":138,"_path":139},"📕 博客","/tools/blog",{"title":141,"_path":142},"🥥 Coconut","/tools/coconut",{"title":144,"_path":145},"🧶 网易云音乐歌单排序","/tools/netease-sorter",{"title":147,"_path":148},"🌐 AnySort","/tools/anysort",{"title":150,"_path":151},"⛸️ UseScrollbar","/tools/use-scrollbar",{"title":153,"_path":154},"👓 Crapto","/tools/crypto-inline",{"title":156,"_path":157,"children":158},"我 / About","/hire",[159],{"title":160,"_path":157},"📬 技术简历",{"_path":162,"_dir":163,"_draft":164,"_partial":165,"_locale":166,"title":167,"description":168,"body":169,"_type":811,"_id":812,"_source":813,"_file":814,"_stem":815,"_extension":816},"/maps/_fe-framework/ui/vue","ui",false,true,"","Vue","Vue 是一套用于构建用户界面的渐进式框架，它的核心库只关注视图层，易于上手，同时也便于与第三方库或既有项目整合。",{"type":170,"children":171,"toc":795},"root",[172,181,208,213,220,238,244,250,255,260,266,271,277,300,306,324,330,335,340,345,357,362,368,373,378,384,395,400,406,415,421,427,432,438,449,460,471,482,487,493,498,504,509,515,520,526,532,537,543,547,557,563,574,579,584,589,594,608,621,626,639,644,657,662,721,766,771,777,789],{"type":173,"tag":174,"props":175,"children":177},"element","h2",{"id":176},"todo",[178],{"type":179,"value":180},"text","TODO",{"type":173,"tag":182,"props":183,"children":184},"ul",{},[185,198],{"type":173,"tag":186,"props":187,"children":188},"li",{},[189],{"type":173,"tag":190,"props":191,"children":195},"a",{"href":192,"rel":193},"https://www.zhihu.com/question/390956688/answer/1184696066",[194],"nofollow",[196],{"type":179,"value":197},"Vue.js 技术揭秘",{"type":173,"tag":186,"props":199,"children":200},{},[201],{"type":173,"tag":190,"props":202,"children":205},{"href":203,"rel":204},"https://github.com/HcySunYang/vue-design/blob/elegant/docs/art/1start-learn",[194],[206],{"type":179,"value":207},"vue-design",{"type":173,"tag":174,"props":209,"children":211},{"id":210},"简介",[212],{"type":179,"value":210},{"type":173,"tag":214,"props":215,"children":217},"h4",{"id":216},"前端框架发展历史关键点",[218],{"type":179,"value":219},"前端框架发展历史关键点？",{"type":173,"tag":182,"props":221,"children":222},{},[223,228,233],{"type":173,"tag":186,"props":224,"children":225},{},[226],{"type":179,"value":227},"2004 年，Google Gmail 使用的 Ajax 技术使前端脱离模板的束缚。",{"type":173,"tag":186,"props":229,"children":230},{},[231],{"type":179,"value":232},"jQuery 解决了不同浏览器的兼容性问题。",{"type":173,"tag":186,"props":234,"children":235},{},[236],{"type":179,"value":237},"2009 年，AngularJS 引领了 MVVM 的潮流，NodeJS 加速了前端工程化的诞生。",{"type":173,"tag":214,"props":239,"children":241},{"id":240},"vue-和-react-的计算性能瓶颈是什么",[242],{"type":179,"value":243},"Vue 和 React 的计算性能瓶颈是什么？",{"type":173,"tag":245,"props":246,"children":247},"p",{},[248],{"type":179,"value":249},"Vue1 的每一个响应式数据都有一个 Watcher，极大的消耗内存，React 的问题发生在当页面 JS 执行 Diff 算法超过帧时间时带来的卡顿问题。",{"type":173,"tag":245,"props":251,"children":252},{},[253],{"type":179,"value":254},"Vue2 引入虚拟 DOM，采用组件级别的响应式数据颗粒度，在避免了 Diff 算法超时问题的同时，降低内存消耗。同时，虚拟 DOM 还带来跨端能力。",{"type":173,"tag":245,"props":256,"children":257},{},[258],{"type":179,"value":259},"React 引入 Fiber 架构，将 DOM Tree 变成链表，使得有能力随时启动或停止 Diff 算法（树的遍历使用递归所以相比链表更难记录状态），可以利用浏览器的空闲时间计算 Diff，避免了卡顿。",{"type":173,"tag":214,"props":261,"children":263},{"id":262},"mvvmmvc-的区别",[264],{"type":179,"value":265},"MVVM、MVC 的区别？",{"type":173,"tag":245,"props":267,"children":268},{},[269],{"type":179,"value":270},"都是软件架构模式，主要区别是关注点不一样，Controller 用来承接交互操作并触发 Model 的修改，而 ViewModel 和 Model 层是双向绑定的，所以写 VueJS 时的思想不在如何操作 DOM 元素，而主要是数据应该怎么变化。",{"type":173,"tag":214,"props":272,"children":274},{"id":273},"vue2-较明显的设计缺陷",[275],{"type":179,"value":276},"Vue2 较明显的设计缺陷？",{"type":173,"tag":182,"props":278,"children":279},{},[280,285,290,295],{"type":173,"tag":186,"props":281,"children":282},{},[283],{"type":179,"value":284},"使用 Flow.js 来做类型校验，而不是社区所向的 TypeScript",{"type":173,"tag":186,"props":286,"children":287},{},[288],{"type":179,"value":289},"Vue2 内嵌了诸如 DOM API 之类的代码，使得跨端等二次开发变得困难，代码耦合也使得摇树优化变得困难",{"type":173,"tag":186,"props":291,"children":292},{},[293],{"type":179,"value":294},"Vue2 使用的 defineProperty 有缺陷，不支持 delete 等操作符",{"type":173,"tag":186,"props":296,"children":297},{},[298],{"type":179,"value":299},"Option API 在组件代码较多时不易维护",{"type":173,"tag":214,"props":301,"children":303},{"id":302},"option-api-的一些缺陷",[304],{"type":179,"value":305},"Option API 的一些缺陷？",{"type":173,"tag":182,"props":307,"children":308},{},[309,314,319],{"type":173,"tag":186,"props":310,"children":311},{},[312],{"type":179,"value":313},"数据挂载在 this 对象上，对类型系统以及摇树优化不友好",{"type":173,"tag":186,"props":315,"children":316},{},[317],{"type":179,"value":318},"代码增多时，维护变得困难",{"type":173,"tag":186,"props":320,"children":321},{},[322],{"type":179,"value":323},"不方便抽离通用逻辑",{"type":173,"tag":214,"props":325,"children":327},{"id":326},"为什么要重写-vue2",[328],{"type":179,"value":329},"为什么要重写 Vue2？",{"type":173,"tag":245,"props":331,"children":332},{},[333],{"type":179,"value":334},"有两个关键因素：主流浏览器逐渐兼容 Proxy，以及修复 Vue2 的设计缺陷。",{"type":173,"tag":245,"props":336,"children":337},{},[338],{"type":179,"value":339},"切换到 Proxy 可以修复过去 setter、getter 无法拦截数组修改以及修改了对象本身带来的语义变化的问题，但由于它是一个原生特性，无法 polyfill，所以对 Vue 而言是一个重大的突破性变动。",{"type":173,"tag":245,"props":341,"children":342},{},[343],{"type":179,"value":344},"过去的架构带来了模板很难正确的在 source-map 中追溯、渲染器（如 DOM 渲染器）不是渐进式的可选项的问题，再加上框架内部代码的耦合，使得摇树优化变得困难，代码也不便理解。",{"type":173,"tag":245,"props":346,"children":347},{},[348,350],{"type":179,"value":349},"见：",{"type":173,"tag":190,"props":351,"children":354},{"href":352,"rel":353},"https://zhuanlan.zhihu.com/p/147022323",[194],[355],{"type":179,"value":356},"重头来过的 Vue 3 带来了什么？",{"type":173,"tag":174,"props":358,"children":360},{"id":359},"响应式",[361],{"type":179,"value":359},{"type":173,"tag":214,"props":363,"children":365},{"id":364},"ref-的原理",[366],{"type":179,"value":367},"ref 的原理？",{"type":173,"tag":245,"props":369,"children":370},{},[371],{"type":179,"value":372},"ref 是在基础值的外面封装了一层对象，使用对象的 value setting、value getter 函数拦截并操作 value 属性，达到响应式的效果。",{"type":173,"tag":174,"props":374,"children":376},{"id":375},"模板",[377],{"type":179,"value":375},{"type":173,"tag":214,"props":379,"children":381},{"id":380},"vue3-双向绑定的原理",[382],{"type":179,"value":383},"Vue3 双向绑定的原理？",{"type":173,"tag":245,"props":385,"children":386},{},[387,388],{"type":179,"value":349},{"type":173,"tag":190,"props":389,"children":392},{"href":390,"rel":391},"https://segmentfault.com/a/1190000041716718",[194],[393],{"type":179,"value":394},"TODO，Vue.js 3.x 双向绑定原理",{"type":173,"tag":174,"props":396,"children":398},{"id":397},"编译器",[399],{"type":179,"value":397},{"type":173,"tag":214,"props":401,"children":403},{"id":402},"vue3-做的静态优化有哪些",[404],{"type":179,"value":405},"Vue3 做的静态优化有哪些？",{"type":173,"tag":245,"props":407,"children":408},{},[409],{"type":173,"tag":410,"props":411,"children":414},"img",{"alt":412,"src":413},"Vue3 Compiler Example","https://mgear-image.oss-cn-shanghai.aliyuncs.com/image/other/20220628022452.png",[],{"type":173,"tag":174,"props":416,"children":418},{"id":417},"vdom",[419],{"type":179,"value":420},"VDOM",{"type":173,"tag":214,"props":422,"children":424},{"id":423},"vue2-和-vue3-的-dom-diff-算法有什么不同",[425],{"type":179,"value":426},"Vue2 和 Vue3 的 DOM Diff 算法有什么不同？",{"type":173,"tag":245,"props":428,"children":429},{},[430],{"type":179,"value":431},"Vue2 使用双端 diff，Vue3 使用最长递增子序列。",{"type":173,"tag":433,"props":434,"children":436},"h3",{"id":435},"todo-1",[437],{"type":179,"value":180},{"type":173,"tag":245,"props":439,"children":440},{},[441,443],{"type":179,"value":442},"为什么 React 的 Diff 算法不采用 Vue 的双端对比算法？",{"type":173,"tag":190,"props":444,"children":447},{"href":445,"rel":446},"https://juejin.cn/post/7116141318853623839",[194],[448],{"type":179,"value":445},{"type":173,"tag":245,"props":450,"children":451},{},[452,454],{"type":179,"value":453},"diff 算法深入一下？",{"type":173,"tag":190,"props":455,"children":458},{"href":456,"rel":457},"https://zhuanlan.zhihu.com/p/401340016",[194],[459],{"type":179,"value":456},{"type":173,"tag":245,"props":461,"children":462},{},[463,465],{"type":179,"value":464},"聊聊 Vue 的双端 diff 算法 ",{"type":173,"tag":190,"props":466,"children":469},{"href":467,"rel":468},"https://zhuanlan.zhihu.com/p/534903909",[194],[470],{"type":179,"value":467},{"type":173,"tag":245,"props":472,"children":473},{},[474,476],{"type":179,"value":475},"diff 算法之双端对比 ",{"type":173,"tag":190,"props":477,"children":480},{"href":478,"rel":479},"https://zhuanlan.zhihu.com/p/432927438",[194],[481],{"type":179,"value":478},{"type":173,"tag":174,"props":483,"children":485},{"id":484},"组件",[486],{"type":179,"value":484},{"type":173,"tag":214,"props":488,"children":490},{"id":489},"keep-alive-的理解它是如何实现的具体缓存的是什么",[491],{"type":179,"value":492},"keep-alive 的理解，它是如何实现的，具体缓存的是什么？",{"type":173,"tag":245,"props":494,"children":495},{},[496],{"type":179,"value":497},"keep-alive 是一个内置抽象组件，会根据内部组件的 key，使用 LRU 策略来缓存组件实例。",{"type":173,"tag":214,"props":499,"children":501},{"id":500},"vue-的生命周期",[502],{"type":179,"value":503},"Vue 的生命周期",{"type":173,"tag":245,"props":505,"children":506},{},[507],{"type":179,"value":508},"keep-alive 独有 activated 和 deactivated 两个生命周期。",{"type":173,"tag":214,"props":510,"children":512},{"id":511},"vue-子组件和父组件执行顺序",[513],{"type":179,"value":514},"Vue 子组件和父组件执行顺序",{"type":173,"tag":245,"props":516,"children":517},{},[518],{"type":179,"value":519},"父组件 mount 前，初始化子组件，所以父组件 beforeMount 后直到子组件 mounted 完成，再挂载。update 和 destroy 两个阶段类似，都是子组件先行。",{"type":173,"tag":174,"props":521,"children":523},{"id":522},"vue-router",[524],{"type":179,"value":525},"Vue Router",{"type":173,"tag":214,"props":527,"children":529},{"id":528},"route-vs-router",[530],{"type":179,"value":531},"$route VS $router",{"type":173,"tag":245,"props":533,"children":534},{},[535],{"type":179,"value":536},"$route 是路由信息对象，包含 path、params、hash、query 等，$router 是 vue-router 实例，包含路由跳转方法和钩子函数等。",{"type":173,"tag":174,"props":538,"children":540},{"id":539},"ssr",[541],{"type":179,"value":542},"SSR",{"type":173,"tag":245,"props":544,"children":545},{},[546],{"type":179,"value":180},{"type":173,"tag":245,"props":548,"children":549},{},[550],{"type":173,"tag":190,"props":551,"children":554},{"href":552,"rel":553},"https://vuejs.org/guide/scaling-up/ssr.html",[194],[555],{"type":179,"value":556},"Vue SSR",{"type":173,"tag":174,"props":558,"children":560},{"id":559},"with-typescript",[561],{"type":179,"value":562},"with TypeScript",{"type":173,"tag":214,"props":564,"children":566},{"id":565},"using-vue-with-typescript",[567],{"type":173,"tag":190,"props":568,"children":571},{"href":569,"rel":570},"https://vuejs.org/guide/typescript/overview.html",[194],[572],{"type":179,"value":573},"Using Vue with TypeScript",{"type":173,"tag":245,"props":575,"children":576},{},[577],{"type":179,"value":578},"\"With a Vite-based setup, the dev server and the bundler are transpilation-only and do not perform any type-checking.\"",{"type":173,"tag":245,"props":580,"children":581},{},[582],{"type":179,"value":583},"Vite-based 的项目不会在开发服务器启用类型检查。Vue 推荐开发者依赖 IDE 进行类型检查，或使用 vue-tsc watch mode、使用 vite-plugin-checker 另起线程插件。Vue 认为类型检查降低开发环境的速度是不值得的。",{"type":173,"tag":245,"props":585,"children":586},{},[587],{"type":179,"value":588},"两个 tsconfig.json 编译选项必须开启：isolatedModule 以便允许 esbuild 解析模块、noImplicitThis 以便启用 this 的类型。",{"type":173,"tag":245,"props":590,"children":591},{},[592],{"type":179,"value":593},"“but for each project we are running two TS language service instances: one from Volar, one from VSCode's built-in service”",{"type":173,"tag":245,"props":595,"children":596},{},[597,599,606],{"type":179,"value":598},"禁用 ",{"type":173,"tag":600,"props":601,"children":603},"code",{"className":602},[],[604],{"type":179,"value":605},"@builtin",{"type":179,"value":607}," TS 插件或打开 Volar 的 Takeover Mode，重启后便能使 Takeover Mode 生效。",{"type":173,"tag":245,"props":609,"children":610},{},[611,613,619],{"type":179,"value":612},"“... with ",{"type":173,"tag":600,"props":614,"children":616},{"className":615},[],[617],{"type":179,"value":618},"ts-loader",{"type":179,"value":620},". This, however, isn't a clean solution because the type system needs knowledge of the entire module graph to perform type checks”",{"type":173,"tag":245,"props":622,"children":623},{},[624],{"type":179,"value":625},"使用 loader 用来类型检查的两个缺陷：检测缓慢阻塞编译、只能解析预解析后的文件所以报错不能直接跳转回源码。",{"type":173,"tag":245,"props":627,"children":628},{},[629,631,637],{"type":179,"value":630},"“In version 3.2 and below, the generic type parameter for ",{"type":173,"tag":600,"props":632,"children":634},{"className":633},[],[635],{"type":179,"value":636},"defineProps()",{"type":179,"value":638}," were limited to a type literal or a reference to a local interface. This limitation has been resolved in 3.3.”",{"type":173,"tag":245,"props":640,"children":641},{},[642],{"type":179,"value":643},"TODO。为什么 Vue 3.2 不能使用外部引入的 Props 作为 type-based defineProps？Vue 3.3 是如何解决的？runtime-declare defineProps 和 runtime-declare emits 会不会对性能有影响？",{"type":173,"tag":245,"props":645,"children":646},{},[647,649,655],{"type":179,"value":648},"“specify a generic type argument but omit the initial value, the resulting type will be a union type that includes ",{"type":173,"tag":600,"props":650,"children":652},{"className":651},[],[653],{"type":179,"value":654},"undefined",{"type":179,"value":656},"”",{"type":173,"tag":245,"props":658,"children":659},{},[660],{"type":179,"value":661},"如果不包含初始值，ref 的类型推断会自动包含 undefined。",{"type":173,"tag":663,"props":664,"children":668},"pre",{"className":665,"code":666,"language":667,"meta":166,"style":166},"language-vue shiki shiki-themes material-theme-lighter github-light github-dark monokai","// inferred type: Ref\u003Cnumber | undefined>\nconst n = ref\u003Cnumber>()\n","vue",[669],{"type":173,"tag":600,"props":670,"children":671},{"__ignoreMap":166},[672,712],{"type":173,"tag":673,"props":674,"children":677},"span",{"class":675,"line":676},"line",1,[678,684,690,696,702,707],{"type":173,"tag":673,"props":679,"children":681},{"style":680},"--shiki-light:#90A4AE;--shiki-default:#24292E;--shiki-dark:#E1E4E8;--shiki-sepia:#F8F8F2",[682],{"type":179,"value":683},"// inferred type: Ref",{"type":173,"tag":673,"props":685,"children":687},{"style":686},"--shiki-light:#39ADB5;--shiki-default:#24292E;--shiki-dark:#E1E4E8;--shiki-sepia:#F8F8F2",[688],{"type":179,"value":689},"\u003C",{"type":173,"tag":673,"props":691,"children":693},{"style":692},"--shiki-light:#E53935;--shiki-default:#22863A;--shiki-dark:#85E89D;--shiki-sepia:#F92672",[694],{"type":179,"value":695},"number",{"type":173,"tag":673,"props":697,"children":699},{"style":698},"--shiki-light:#9C3EDA;--shiki-default:#6F42C1;--shiki-dark:#B392F0;--shiki-sepia:#A6E22E",[700],{"type":179,"value":701}," |",{"type":173,"tag":673,"props":703,"children":704},{"style":698},[705],{"type":179,"value":706}," undefined",{"type":173,"tag":673,"props":708,"children":709},{"style":686},[710],{"type":179,"value":711},">\n",{"type":173,"tag":673,"props":713,"children":715},{"class":675,"line":714},2,[716],{"type":173,"tag":673,"props":717,"children":718},{"style":680},[719],{"type":179,"value":720},"const n = ref\u003Cnumber>()\n",{"type":173,"tag":245,"props":722,"children":723},{},[724,726,732,734,740,742,748,750,756,758,764],{"type":179,"value":725},"”Without type annotation, the ",{"type":173,"tag":600,"props":727,"children":729},{"className":728},[],[730],{"type":179,"value":731},"event",{"type":179,"value":733}," argument will implicitly have a type of ",{"type":173,"tag":600,"props":735,"children":737},{"className":736},[],[738],{"type":179,"value":739},"any",{"type":179,"value":741},". This will also result in a TS error if ",{"type":173,"tag":600,"props":743,"children":745},{"className":744},[],[746],{"type":179,"value":747},"\"strict\": true",{"type":179,"value":749}," or ",{"type":173,"tag":600,"props":751,"children":753},{"className":752},[],[754],{"type":179,"value":755},"\"noImplicitAny\": true",{"type":179,"value":757}," are used in ",{"type":173,"tag":600,"props":759,"children":761},{"className":760},[],[762],{"type":179,"value":763},"tsconfig.json",{"type":179,"value":765},".“",{"type":173,"tag":245,"props":767,"children":768},{},[769],{"type":179,"value":770},"因为 noImplicitAny 需要打开，不然没法推断 options api 函数中 this 的类型，所以在组件中，接受事件的函数面对 Event 参数必须显式指定类型，不然就会报错。",{"type":173,"tag":174,"props":772,"children":774},{"id":773},"source",[775],{"type":179,"value":776},"Source",{"type":173,"tag":182,"props":778,"children":779},{},[780],{"type":173,"tag":186,"props":781,"children":782},{},[783],{"type":173,"tag":190,"props":784,"children":786},{"href":785},"/source-code/_js/vue2-source",[787],{"type":179,"value":788},"Vue2 Source",{"type":173,"tag":790,"props":791,"children":792},"style",{},[793],{"type":179,"value":794},"html .light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html.light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"title":166,"searchDepth":714,"depth":714,"links":796},[797,798,799,800,801,802,806,807,808,809,810],{"id":176,"depth":714,"text":180},{"id":210,"depth":714,"text":210},{"id":359,"depth":714,"text":359},{"id":375,"depth":714,"text":375},{"id":397,"depth":714,"text":397},{"id":417,"depth":714,"text":420,"children":803},[804],{"id":435,"depth":805,"text":180},3,{"id":484,"depth":714,"text":484},{"id":522,"depth":714,"text":525},{"id":539,"depth":714,"text":542},{"id":559,"depth":714,"text":562},{"id":773,"depth":714,"text":776},"markdown","content:6.maps:_fe-framework:ui:vue.md","content","6.maps/_fe-framework/ui/vue.md","6.maps/_fe-framework/ui/vue","md",[818,822],{"_path":819,"title":820,"description":821},"/maps/_fe-framework/ui/react","React Mind Map","React 是一个经典的用户界面框架。",{"_path":823,"title":824,"description":825},"/maps/_fe-framework/web-components","Web Components","Web Components 是一种 Web 开发技术，它允许开发者创建自定义的、可重用的组件，这些组件可以在不同的 Web 应用中使用。",1761757115602]