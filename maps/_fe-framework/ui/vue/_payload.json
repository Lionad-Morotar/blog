[{"data":1,"prerenderedAt":801},["ShallowReactive",2],{"navigation":3,"/maps/_fe-framework/ui/vue":155,"/maps/_fe-framework/ui/vue-surround":792},[4,35,86,92,119,125,149],{"title":5,"_path":6,"children":7},"心流思绪 / Heart Flows","/flows",[8,11,14,17,20,23,26,29,32],{"title":9,"_path":10},"📕 狮子的书单推荐","/flows/books",{"title":12,"_path":13},"🚝 四十二篇系列","/flows/fourty-two",{"title":15,"_path":16},"🌃 长夜梦","/flows/long-night-dream",{"title":18,"_path":19},"🌌 万物联结与幸福感","/flows/everything",{"title":21,"_path":22},"⌛ 偷取时间","/flows/stealing-time-from-god",{"title":24,"_path":25},"🌆 表达和孤独","/flows/expression-and-loneliness",{"title":27,"_path":28},"🌧️ 我的腼腆","/flows/shy",{"title":30,"_path":31},"🥛 新工作，喝新饮料","/flows/drinking-while-thinking",{"title":33,"_path":34},"📝 心流归档","/flows/archive",{"title":36,"_path":37,"children":38},"技术博客 / Coder","/articles",[39,41,44,47,50,53,56,59,62,65,68,71,74,77,80,83],{"title":40,"_path":37},"🦁 欢迎",{"title":42,"_path":43},"🥞 在 tailwind 中使用现代化 CSS Layers","/articles/tailwind-sass-and-css-layer",{"title":45,"_path":46},"💻 本地部署 Qwen 翻译网页","/articles/local-translator",{"title":48,"_path":49},"🧊 模板解析器轻考古","/articles/micro-templating",{"title":51,"_path":52},"Ⓜ️ Mini CSS Parser","/articles/mini-css-parser",{"title":54,"_path":55},"🚩 向AI咨询前端问题","/articles/use-gpt-learn-complex-frontend",{"title":57,"_path":58},"⛸️ 怎样定制复杂组件的自定义滚动条？","/articles/use-scrollbars",{"title":60,"_path":61},"⚖️ 统一多组件库的层叠顺序","/articles/zindex-manager",{"title":63,"_path":64},"🕷️ 滑动验证码破解思路","/articles/crack-the-slider",{"title":66,"_path":67},"🌟 探秘 CSS 光影效果","/articles/css-light-travel",{"title":69,"_path":70},"🍲 设计模式与 JS 魔法锅","/articles/design-patterns-and-js-magic-pot",{"title":72,"_path":73},"🌐 Anysort：灵活、优雅的多属性排序","/articles/anysort-2th",{"title":75,"_path":76},"💫 CSS 幻术 | 抗锯齿","/articles/css-poaa",{"title":78,"_path":79},"❓ 用纯CSS判断鼠标进入的方向","/articles/css-judge-direction",{"title":81,"_path":82},"📝 你本可以少写些 if-else","/articles/no-more-if-else",{"title":84,"_path":85},"📝 技术博客归档","/articles/archive",{"title":87,"_path":88,"children":89},"读书笔记 / Notes","/books",[90],{"title":91,"_path":88},"📕 读书笔记",{"title":93,"_path":94,"children":95},"吉他剧场 / Music","/music",[96,98,101,104,107,110,113,116],{"title":97,"_path":94},"🎸 FingerStyle！",{"title":99,"_path":100},"🌬️ 等待的风","/music/wind",{"title":102,"_path":103},"💕 约定的海洋","/music/ocean",{"title":105,"_path":106},"🎼 Wings~You are the Hero！","/music/wings-you-are-the-hero",{"title":108,"_path":109},"🌏 残酷天使的行动纲领","/music/eva",{"title":111,"_path":112},"🏔️ 奇跡の山","/music/miracle-mountain",{"title":114,"_path":115},"🍷 Wu Wei","/music/wu-wei",{"title":117,"_path":118},"🌅 无题","/music/untitled",{"title":120,"_path":121,"children":122},"知识地图 / Maps","/maps",[123],{"title":124,"_path":121},"🏁 知识地图",{"title":126,"_path":127,"children":128},"造物 / Make","/tools",[129,131,134,137,140,143,146],{"title":130,"_path":127},"🧰 工具收集",{"title":132,"_path":133},"📕 博客","/tools/blog",{"title":135,"_path":136},"🥥 Coconut","/tools/coconut",{"title":138,"_path":139},"🧶 网易云音乐歌单排序","/tools/netease-sorter",{"title":141,"_path":142},"🌐 AnySort","/tools/anysort",{"title":144,"_path":145},"⛸️ UseScrollbar","/tools/use-scrollbar",{"title":147,"_path":148},"👓 Crapto","/tools/crypto-inline",{"title":150,"_path":151,"children":152},"我 / About","/hire",[153],{"title":154,"_path":151},"📬 技术简历",{"_path":156,"_dir":157,"_draft":158,"_partial":159,"_locale":160,"title":161,"description":162,"body":163,"_type":786,"_id":787,"_source":788,"_file":789,"_stem":790,"_extension":791},"/maps/_fe-framework/ui/vue","ui",false,true,"","Vue","Vue 是一套用于构建用户界面的渐进式框架，它的核心库只关注视图层，易于上手，同时也便于与第三方库或既有项目整合。",{"type":164,"children":165,"toc":771},"root",[166,175,202,207,214,232,238,244,249,254,260,265,271,294,300,318,324,329,334,339,351,356,362,367,372,378,389,394,400,409,415,421,426,432,443,454,465,476,481,487,492,498,503,509,514,520,526,531,537,541,551,557,568,573,578,583,588,602,615,620,633,638,651,656,715,760,765],{"type":167,"tag":168,"props":169,"children":171},"element","h2",{"id":170},"todo",[172],{"type":173,"value":174},"text","TODO",{"type":167,"tag":176,"props":177,"children":178},"ul",{},[179,192],{"type":167,"tag":180,"props":181,"children":182},"li",{},[183],{"type":167,"tag":184,"props":185,"children":189},"a",{"href":186,"rel":187},"https://www.zhihu.com/question/390956688/answer/1184696066",[188],"nofollow",[190],{"type":173,"value":191},"Vue.js 技术揭秘",{"type":167,"tag":180,"props":193,"children":194},{},[195],{"type":167,"tag":184,"props":196,"children":199},{"href":197,"rel":198},"https://github.com/HcySunYang/vue-design/blob/elegant/docs/art/1start-learn",[188],[200],{"type":173,"value":201},"vue-design",{"type":167,"tag":168,"props":203,"children":205},{"id":204},"简介",[206],{"type":173,"value":204},{"type":167,"tag":208,"props":209,"children":211},"h4",{"id":210},"前端框架发展历史关键点",[212],{"type":173,"value":213},"前端框架发展历史关键点？",{"type":167,"tag":176,"props":215,"children":216},{},[217,222,227],{"type":167,"tag":180,"props":218,"children":219},{},[220],{"type":173,"value":221},"2004 年，Google Gmail 使用的 Ajax 技术使前端脱离模板的束缚。",{"type":167,"tag":180,"props":223,"children":224},{},[225],{"type":173,"value":226},"jQuery 解决了不同浏览器的兼容性问题。",{"type":167,"tag":180,"props":228,"children":229},{},[230],{"type":173,"value":231},"2009 年，AngularJS 引领了 MVVM 的潮流，NodeJS 加速了前端工程化的诞生。",{"type":167,"tag":208,"props":233,"children":235},{"id":234},"vue-和-react-的计算性能瓶颈是什么",[236],{"type":173,"value":237},"Vue 和 React 的计算性能瓶颈是什么？",{"type":167,"tag":239,"props":240,"children":241},"p",{},[242],{"type":173,"value":243},"Vue1 的每一个响应式数据都有一个 Watcher，极大的消耗内存，React 的问题发生在当页面 JS 执行 Diff 算法超过帧时间时带来的卡顿问题。",{"type":167,"tag":239,"props":245,"children":246},{},[247],{"type":173,"value":248},"Vue2 引入虚拟 DOM，采用组件级别的响应式数据颗粒度，在避免了 Diff 算法超时问题的同时，降低内存消耗。同时，虚拟 DOM 还带来跨端能力。",{"type":167,"tag":239,"props":250,"children":251},{},[252],{"type":173,"value":253},"React 引入 Fiber 架构，将 DOM Tree 变成链表，使得有能力随时启动或停止 Diff 算法（树的遍历使用递归所以相比链表更难记录状态），可以利用浏览器的空闲时间计算 Diff，避免了卡顿。",{"type":167,"tag":208,"props":255,"children":257},{"id":256},"mvvmmvc-的区别",[258],{"type":173,"value":259},"MVVM、MVC 的区别？",{"type":167,"tag":239,"props":261,"children":262},{},[263],{"type":173,"value":264},"都是软件架构模式，主要区别是关注点不一样，Controller 用来承接交互操作并触发 Model 的修改，而 ViewModel 和 Model 层是双向绑定的，所以写 VueJS 时的思想不在如何操作 DOM 元素，而主要是数据应该怎么变化。",{"type":167,"tag":208,"props":266,"children":268},{"id":267},"vue2-较明显的设计缺陷",[269],{"type":173,"value":270},"Vue2 较明显的设计缺陷？",{"type":167,"tag":176,"props":272,"children":273},{},[274,279,284,289],{"type":167,"tag":180,"props":275,"children":276},{},[277],{"type":173,"value":278},"使用 Flow.js 来做类型校验，而不是社区所向的 TypeScript",{"type":167,"tag":180,"props":280,"children":281},{},[282],{"type":173,"value":283},"Vue2 内嵌了诸如 DOM API 之类的代码，使得跨端等二次开发变得困难，代码耦合也使得摇树优化变得困难",{"type":167,"tag":180,"props":285,"children":286},{},[287],{"type":173,"value":288},"Vue2 使用的 defineProperty 有缺陷，不支持 delete 等操作符",{"type":167,"tag":180,"props":290,"children":291},{},[292],{"type":173,"value":293},"Option API 在组件代码较多时不易维护",{"type":167,"tag":208,"props":295,"children":297},{"id":296},"option-api-的一些缺陷",[298],{"type":173,"value":299},"Option API 的一些缺陷？",{"type":167,"tag":176,"props":301,"children":302},{},[303,308,313],{"type":167,"tag":180,"props":304,"children":305},{},[306],{"type":173,"value":307},"数据挂载在 this 对象上，对类型系统以及摇树优化不友好",{"type":167,"tag":180,"props":309,"children":310},{},[311],{"type":173,"value":312},"代码增多时，维护变得困难",{"type":167,"tag":180,"props":314,"children":315},{},[316],{"type":173,"value":317},"不方便抽离通用逻辑",{"type":167,"tag":208,"props":319,"children":321},{"id":320},"为什么要重写-vue2",[322],{"type":173,"value":323},"为什么要重写 Vue2？",{"type":167,"tag":239,"props":325,"children":326},{},[327],{"type":173,"value":328},"有两个关键因素：主流浏览器逐渐兼容 Proxy，以及修复 Vue2 的设计缺陷。",{"type":167,"tag":239,"props":330,"children":331},{},[332],{"type":173,"value":333},"切换到 Proxy 可以修复过去 setter、getter 无法拦截数组修改以及修改了对象本身带来的语义变化的问题，但由于它是一个原生特性，无法 polyfill，所以对 Vue 而言是一个重大的突破性变动。",{"type":167,"tag":239,"props":335,"children":336},{},[337],{"type":173,"value":338},"过去的架构带来了模板很难正确的在 source-map 中追溯、渲染器（如 DOM 渲染器）不是渐进式的可选项的问题，再加上框架内部代码的耦合，使得摇树优化变得困难，代码也不便理解。",{"type":167,"tag":239,"props":340,"children":341},{},[342,344],{"type":173,"value":343},"见：",{"type":167,"tag":184,"props":345,"children":348},{"href":346,"rel":347},"https://zhuanlan.zhihu.com/p/147022323",[188],[349],{"type":173,"value":350},"重头来过的 Vue 3 带来了什么？",{"type":167,"tag":168,"props":352,"children":354},{"id":353},"响应式",[355],{"type":173,"value":353},{"type":167,"tag":208,"props":357,"children":359},{"id":358},"ref-的原理",[360],{"type":173,"value":361},"ref 的原理？",{"type":167,"tag":239,"props":363,"children":364},{},[365],{"type":173,"value":366},"ref 是在基础值的外面封装了一层对象，使用对象的 value setting、value getter 函数拦截并操作 value 属性，达到响应式的效果。",{"type":167,"tag":168,"props":368,"children":370},{"id":369},"模板",[371],{"type":173,"value":369},{"type":167,"tag":208,"props":373,"children":375},{"id":374},"vue3-双向绑定的原理",[376],{"type":173,"value":377},"Vue3 双向绑定的原理？",{"type":167,"tag":239,"props":379,"children":380},{},[381,382],{"type":173,"value":343},{"type":167,"tag":184,"props":383,"children":386},{"href":384,"rel":385},"https://segmentfault.com/a/1190000041716718",[188],[387],{"type":173,"value":388},"TODO，Vue.js 3.x 双向绑定原理",{"type":167,"tag":168,"props":390,"children":392},{"id":391},"编译器",[393],{"type":173,"value":391},{"type":167,"tag":208,"props":395,"children":397},{"id":396},"vue3-做的静态优化有哪些",[398],{"type":173,"value":399},"Vue3 做的静态优化有哪些？",{"type":167,"tag":239,"props":401,"children":402},{},[403],{"type":167,"tag":404,"props":405,"children":408},"img",{"alt":406,"src":407},"Vue3 Compiler Example","https://mgear-image.oss-cn-shanghai.aliyuncs.com/image/other/20220628022452.png",[],{"type":167,"tag":168,"props":410,"children":412},{"id":411},"vdom",[413],{"type":173,"value":414},"VDOM",{"type":167,"tag":208,"props":416,"children":418},{"id":417},"vue2-和-vue3-的-dom-diff-算法有什么不同",[419],{"type":173,"value":420},"Vue2 和 Vue3 的 DOM Diff 算法有什么不同？",{"type":167,"tag":239,"props":422,"children":423},{},[424],{"type":173,"value":425},"Vue2 使用双端 diff，Vue3 使用最长递增子序列。",{"type":167,"tag":427,"props":428,"children":430},"h3",{"id":429},"todo-1",[431],{"type":173,"value":174},{"type":167,"tag":239,"props":433,"children":434},{},[435,437],{"type":173,"value":436},"为什么 React 的 Diff 算法不采用 Vue 的双端对比算法？",{"type":167,"tag":184,"props":438,"children":441},{"href":439,"rel":440},"https://juejin.cn/post/7116141318853623839",[188],[442],{"type":173,"value":439},{"type":167,"tag":239,"props":444,"children":445},{},[446,448],{"type":173,"value":447},"diff 算法深入一下？",{"type":167,"tag":184,"props":449,"children":452},{"href":450,"rel":451},"https://zhuanlan.zhihu.com/p/401340016",[188],[453],{"type":173,"value":450},{"type":167,"tag":239,"props":455,"children":456},{},[457,459],{"type":173,"value":458},"聊聊 Vue 的双端 diff 算法 ",{"type":167,"tag":184,"props":460,"children":463},{"href":461,"rel":462},"https://zhuanlan.zhihu.com/p/534903909",[188],[464],{"type":173,"value":461},{"type":167,"tag":239,"props":466,"children":467},{},[468,470],{"type":173,"value":469},"diff 算法之双端对比 ",{"type":167,"tag":184,"props":471,"children":474},{"href":472,"rel":473},"https://zhuanlan.zhihu.com/p/432927438",[188],[475],{"type":173,"value":472},{"type":167,"tag":168,"props":477,"children":479},{"id":478},"组件",[480],{"type":173,"value":478},{"type":167,"tag":208,"props":482,"children":484},{"id":483},"keep-alive-的理解它是如何实现的具体缓存的是什么",[485],{"type":173,"value":486},"keep-alive 的理解，它是如何实现的，具体缓存的是什么？",{"type":167,"tag":239,"props":488,"children":489},{},[490],{"type":173,"value":491},"keep-alive 是一个内置抽象组件，会根据内部组件的 key，使用 LRU 策略来缓存组件实例。",{"type":167,"tag":208,"props":493,"children":495},{"id":494},"vue-的生命周期",[496],{"type":173,"value":497},"Vue 的生命周期",{"type":167,"tag":239,"props":499,"children":500},{},[501],{"type":173,"value":502},"keep-alive 独有 activated 和 deactivated 两个生命周期。",{"type":167,"tag":208,"props":504,"children":506},{"id":505},"vue-子组件和父组件执行顺序",[507],{"type":173,"value":508},"Vue 子组件和父组件执行顺序",{"type":167,"tag":239,"props":510,"children":511},{},[512],{"type":173,"value":513},"父组件 mount 前，初始化子组件，所以父组件 beforeMount 后直到子组件 mounted 完成，再挂载。update 和 destroy 两个阶段类似，都是子组件先行。",{"type":167,"tag":168,"props":515,"children":517},{"id":516},"vue-router",[518],{"type":173,"value":519},"Vue Router",{"type":167,"tag":208,"props":521,"children":523},{"id":522},"route-vs-router",[524],{"type":173,"value":525},"$route VS $router",{"type":167,"tag":239,"props":527,"children":528},{},[529],{"type":173,"value":530},"$route 是路由信息对象，包含 path、params、hash、query 等，$router 是 vue-router 实例，包含路由跳转方法和钩子函数等。",{"type":167,"tag":168,"props":532,"children":534},{"id":533},"ssr",[535],{"type":173,"value":536},"SSR",{"type":167,"tag":239,"props":538,"children":539},{},[540],{"type":173,"value":174},{"type":167,"tag":239,"props":542,"children":543},{},[544],{"type":167,"tag":184,"props":545,"children":548},{"href":546,"rel":547},"https://vuejs.org/guide/scaling-up/ssr.html",[188],[549],{"type":173,"value":550},"Vue SSR",{"type":167,"tag":168,"props":552,"children":554},{"id":553},"with-typescript",[555],{"type":173,"value":556},"with TypeScript",{"type":167,"tag":208,"props":558,"children":560},{"id":559},"using-vue-with-typescript",[561],{"type":167,"tag":184,"props":562,"children":565},{"href":563,"rel":564},"https://vuejs.org/guide/typescript/overview.html",[188],[566],{"type":173,"value":567},"Using Vue with TypeScript",{"type":167,"tag":239,"props":569,"children":570},{},[571],{"type":173,"value":572},"\"With a Vite-based setup, the dev server and the bundler are transpilation-only and do not perform any type-checking.\"",{"type":167,"tag":239,"props":574,"children":575},{},[576],{"type":173,"value":577},"Vite-based 的项目不会在开发服务器启用类型检查。Vue 推荐开发者依赖 IDE 进行类型检查，或使用 vue-tsc watch mode、使用 vite-plugin-checker 另起线程插件。Vue 认为类型检查降低开发环境的速度是不值得的。",{"type":167,"tag":239,"props":579,"children":580},{},[581],{"type":173,"value":582},"两个 tsconfig.json 编译选项必须开启：isolatedModule 以便允许 esbuild 解析模块、noImplicitThis 以便启用 this 的类型。",{"type":167,"tag":239,"props":584,"children":585},{},[586],{"type":173,"value":587},"“but for each project we are running two TS language service instances: one from Volar, one from VSCode's built-in service”",{"type":167,"tag":239,"props":589,"children":590},{},[591,593,600],{"type":173,"value":592},"禁用 ",{"type":167,"tag":594,"props":595,"children":597},"code",{"className":596},[],[598],{"type":173,"value":599},"@builtin",{"type":173,"value":601}," TS 插件或打开 Volar 的 Takeover Mode，重启后便能使 Takeover Mode 生效。",{"type":167,"tag":239,"props":603,"children":604},{},[605,607,613],{"type":173,"value":606},"“... with ",{"type":167,"tag":594,"props":608,"children":610},{"className":609},[],[611],{"type":173,"value":612},"ts-loader",{"type":173,"value":614},". This, however, isn't a clean solution because the type system needs knowledge of the entire module graph to perform type checks”",{"type":167,"tag":239,"props":616,"children":617},{},[618],{"type":173,"value":619},"使用 loader 用来类型检查的两个缺陷：检测缓慢阻塞编译、只能解析预解析后的文件所以报错不能直接跳转回源码。",{"type":167,"tag":239,"props":621,"children":622},{},[623,625,631],{"type":173,"value":624},"“In version 3.2 and below, the generic type parameter for ",{"type":167,"tag":594,"props":626,"children":628},{"className":627},[],[629],{"type":173,"value":630},"defineProps()",{"type":173,"value":632}," were limited to a type literal or a reference to a local interface. This limitation has been resolved in 3.3.”",{"type":167,"tag":239,"props":634,"children":635},{},[636],{"type":173,"value":637},"TODO。为什么 Vue 3.2 不能使用外部引入的 Props 作为 type-based defineProps？Vue 3.3 是如何解决的？runtime-declare defineProps 和 runtime-declare emits 会不会对性能有影响？",{"type":167,"tag":239,"props":639,"children":640},{},[641,643,649],{"type":173,"value":642},"“specify a generic type argument but omit the initial value, the resulting type will be a union type that includes ",{"type":167,"tag":594,"props":644,"children":646},{"className":645},[],[647],{"type":173,"value":648},"undefined",{"type":173,"value":650},"”",{"type":167,"tag":239,"props":652,"children":653},{},[654],{"type":173,"value":655},"如果不包含初始值，ref 的类型推断会自动包含 undefined。",{"type":167,"tag":657,"props":658,"children":662},"pre",{"className":659,"code":660,"language":661,"meta":160,"style":160},"language-vue shiki shiki-themes material-theme-lighter github-light github-dark monokai","// inferred type: Ref\u003Cnumber | undefined>\nconst n = ref\u003Cnumber>()\n","vue",[663],{"type":167,"tag":594,"props":664,"children":665},{"__ignoreMap":160},[666,706],{"type":167,"tag":667,"props":668,"children":671},"span",{"class":669,"line":670},"line",1,[672,678,684,690,696,701],{"type":167,"tag":667,"props":673,"children":675},{"style":674},"--shiki-light:#90A4AE;--shiki-default:#24292E;--shiki-dark:#E1E4E8;--shiki-sepia:#F8F8F2",[676],{"type":173,"value":677},"// inferred type: Ref",{"type":167,"tag":667,"props":679,"children":681},{"style":680},"--shiki-light:#39ADB5;--shiki-default:#24292E;--shiki-dark:#E1E4E8;--shiki-sepia:#F8F8F2",[682],{"type":173,"value":683},"\u003C",{"type":167,"tag":667,"props":685,"children":687},{"style":686},"--shiki-light:#E53935;--shiki-default:#22863A;--shiki-dark:#85E89D;--shiki-sepia:#F92672",[688],{"type":173,"value":689},"number",{"type":167,"tag":667,"props":691,"children":693},{"style":692},"--shiki-light:#9C3EDA;--shiki-default:#6F42C1;--shiki-dark:#B392F0;--shiki-sepia:#A6E22E",[694],{"type":173,"value":695}," |",{"type":167,"tag":667,"props":697,"children":698},{"style":692},[699],{"type":173,"value":700}," undefined",{"type":167,"tag":667,"props":702,"children":703},{"style":680},[704],{"type":173,"value":705},">\n",{"type":167,"tag":667,"props":707,"children":709},{"class":669,"line":708},2,[710],{"type":167,"tag":667,"props":711,"children":712},{"style":674},[713],{"type":173,"value":714},"const n = ref\u003Cnumber>()\n",{"type":167,"tag":239,"props":716,"children":717},{},[718,720,726,728,734,736,742,744,750,752,758],{"type":173,"value":719},"”Without type annotation, the ",{"type":167,"tag":594,"props":721,"children":723},{"className":722},[],[724],{"type":173,"value":725},"event",{"type":173,"value":727}," argument will implicitly have a type of ",{"type":167,"tag":594,"props":729,"children":731},{"className":730},[],[732],{"type":173,"value":733},"any",{"type":173,"value":735},". This will also result in a TS error if ",{"type":167,"tag":594,"props":737,"children":739},{"className":738},[],[740],{"type":173,"value":741},"\"strict\": true",{"type":173,"value":743}," or ",{"type":167,"tag":594,"props":745,"children":747},{"className":746},[],[748],{"type":173,"value":749},"\"noImplicitAny\": true",{"type":173,"value":751}," are used in ",{"type":167,"tag":594,"props":753,"children":755},{"className":754},[],[756],{"type":173,"value":757},"tsconfig.json",{"type":173,"value":759},".“",{"type":167,"tag":239,"props":761,"children":762},{},[763],{"type":173,"value":764},"因为 noImplicitAny 需要打开，不然没法推断 options api 函数中 this 的类型，所以在组件中，接受事件的函数面对 Event 参数必须显式指定类型，不然就会报错。",{"type":167,"tag":766,"props":767,"children":768},"style",{},[769],{"type":173,"value":770},"html .light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html.light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}",{"title":160,"searchDepth":708,"depth":708,"links":772},[773,774,775,776,777,778,782,783,784,785],{"id":170,"depth":708,"text":174},{"id":204,"depth":708,"text":204},{"id":353,"depth":708,"text":353},{"id":369,"depth":708,"text":369},{"id":391,"depth":708,"text":391},{"id":411,"depth":708,"text":414,"children":779},[780],{"id":429,"depth":781,"text":174},3,{"id":478,"depth":708,"text":478},{"id":516,"depth":708,"text":519},{"id":533,"depth":708,"text":536},{"id":553,"depth":708,"text":556},"markdown","content:6.maps:_fe-framework:ui:vue.md","content","6.maps/_fe-framework/ui/vue.md","6.maps/_fe-framework/ui/vue","md",[793,797],{"_path":794,"title":795,"description":796},"/maps/_fe-framework/ui/react","React Mind Map","React 是一个经典的用户界面框架。",{"_path":798,"title":799,"description":800},"/maps/_fe-framework/web-components","Web Components","Web Components 是一种 Web 开发技术，它允许开发者创建自定义的、可重用的组件，这些组件可以在不同的 Web 应用中使用。",1742348691190]