{"_path":"/maps/_framework/ui/vue","_dir":"ui","_draft":false,"_partial":true,"_locale":"","title":"Vue","description":"Vue 是一套用于构建用户界面的渐进式框架，它的核心库只关注视图层，易于上手，同时也便于与第三方库或既有项目整合。","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"todo"},"children":[{"type":"text","value":"TODO"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://www.zhihu.com/question/390956688/answer/1184696066","rel":["nofollow"]},"children":[{"type":"text","value":"Vue.js 技术揭秘"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/HcySunYang/vue-design/blob/elegant/docs/art/1start-learn","rel":["nofollow"]},"children":[{"type":"text","value":"vue-design"}]}]}]},{"type":"element","tag":"h2","props":{"id":"简介"},"children":[{"type":"text","value":"简介"}]},{"type":"element","tag":"h4","props":{"id":"前端框架发展历史关键点"},"children":[{"type":"text","value":"前端框架发展历史关键点？"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"2004 年，Google Gmail 使用的 Ajax 技术使前端脱离模板的束缚。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"jQuery 解决了不同浏览器的兼容性问题。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"2009 年，AngularJS 引领了 MVVM 的潮流，NodeJS 加速了前端工程化的诞生。"}]}]},{"type":"element","tag":"h4","props":{"id":"vue-和-react-的计算性能瓶颈是什么"},"children":[{"type":"text","value":"Vue 和 React 的计算性能瓶颈是什么？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Vue1 的每一个响应式数据都有一个 Watcher，极大的消耗内存，React 的问题发生在当页面 JS 执行 Diff 算法超过帧时间时带来的卡顿问题。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Vue2 引入虚拟 DOM，采用组件级别的响应式数据颗粒度，在避免了 Diff 算法超时问题的同时，降低内存消耗。同时，虚拟 DOM 还带来跨端能力。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"React 引入 Fiber 架构，将 DOM Tree 变成链表，使得有能力随时启动或停止 Diff 算法（树的遍历使用递归所以相比链表更难记录状态），可以利用浏览器的空闲时间计算 Diff，避免了卡顿。"}]},{"type":"element","tag":"h4","props":{"id":"mvvmmvc-的区别"},"children":[{"type":"text","value":"MVVM、MVC 的区别？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"都是软件架构模式，主要区别是关注点不一样，Controller 用来承接交互操作并触发 Model 的修改，而 ViewModel 和 Model 层是双向绑定的，所以写 VueJS 时的思想不在如何操作 DOM 元素，而主要是数据应该怎么变化。"}]},{"type":"element","tag":"h4","props":{"id":"vue2-较明显的设计缺陷"},"children":[{"type":"text","value":"Vue2 较明显的设计缺陷？"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用 Flow.js 来做类型校验，而不是社区所向的 TypeScript"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Vue2 内嵌了诸如 DOM API 之类的代码，使得跨端等二次开发变得困难，代码耦合也使得摇树优化变得困难"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Vue2 使用的 defineProperty 有缺陷，不支持 delete 等操作符"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Option API 在组件代码较多时不易维护"}]}]},{"type":"element","tag":"h4","props":{"id":"option-api-的一些缺陷"},"children":[{"type":"text","value":"Option API 的一些缺陷？"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"数据挂载在 this 对象上，对类型系统以及摇树优化不友好"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"代码增多时，维护变得困难"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不方便抽离通用逻辑"}]}]},{"type":"element","tag":"h4","props":{"id":"为什么要重写-vue2"},"children":[{"type":"text","value":"为什么要重写 Vue2？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"有两个关键因素：主流浏览器逐渐兼容 Proxy，以及修复 Vue2 的设计缺陷。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"切换到 Proxy 可以修复过去 setter、getter 无法拦截数组修改以及修改了对象本身带来的语义变化的问题，但由于它是一个原生特性，无法 polyfill，所以对 Vue 而言是一个重大的突破性变动。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"过去的架构带来了模板很难正确的在 source-map 中追溯、渲染器（如 DOM 渲染器）不是渐进式的可选项的问题，再加上框架内部代码的耦合，使得摇树优化变得困难，代码也不便理解。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"见："},{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/147022323","rel":["nofollow"]},"children":[{"type":"text","value":"重头来过的 Vue 3 带来了什么？"}]}]},{"type":"element","tag":"h2","props":{"id":"响应式"},"children":[{"type":"text","value":"响应式"}]},{"type":"element","tag":"h4","props":{"id":"ref-的原理"},"children":[{"type":"text","value":"ref 的原理？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"ref 是在基础值的外面封装了一层对象，使用对象的 value setting、value getter 函数拦截并操作 value 属性，达到响应式的效果。"}]},{"type":"element","tag":"h2","props":{"id":"模板"},"children":[{"type":"text","value":"模板"}]},{"type":"element","tag":"h4","props":{"id":"vue3-双向绑定的原理"},"children":[{"type":"text","value":"Vue3 双向绑定的原理？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"见："},{"type":"element","tag":"a","props":{"href":"https://segmentfault.com/a/1190000041716718","rel":["nofollow"]},"children":[{"type":"text","value":"TODO，Vue.js 3.x 双向绑定原理"}]}]},{"type":"element","tag":"h2","props":{"id":"编译器"},"children":[{"type":"text","value":"编译器"}]},{"type":"element","tag":"h4","props":{"id":"vue3-做的静态优化有哪些"},"children":[{"type":"text","value":"Vue3 做的静态优化有哪些？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Vue3 Compiler Example","src":"https://mgear-image.oss-cn-shanghai.aliyuncs.com/image/other/20220628022452.png"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"vdom"},"children":[{"type":"text","value":"VDOM"}]},{"type":"element","tag":"h4","props":{"id":"vue2-和-vue3-的-dom-diff-算法有什么不同"},"children":[{"type":"text","value":"Vue2 和 Vue3 的 DOM Diff 算法有什么不同？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Vue2 使用双端 diff，Vue3 使用最长递增子序列。"}]},{"type":"element","tag":"h3","props":{"id":"todo-1"},"children":[{"type":"text","value":"TODO"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"为什么 React 的 Diff 算法不采用 Vue 的双端对比算法？"},{"type":"element","tag":"a","props":{"href":"https://juejin.cn/post/7116141318853623839","rel":["nofollow"]},"children":[{"type":"text","value":"https://juejin.cn/post/7116141318853623839"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"diff 算法深入一下？"},{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/401340016","rel":["nofollow"]},"children":[{"type":"text","value":"https://zhuanlan.zhihu.com/p/401340016"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"聊聊 Vue 的双端 diff 算法 "},{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/534903909","rel":["nofollow"]},"children":[{"type":"text","value":"https://zhuanlan.zhihu.com/p/534903909"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"diff 算法之双端对比 "},{"type":"element","tag":"a","props":{"href":"https://zhuanlan.zhihu.com/p/432927438","rel":["nofollow"]},"children":[{"type":"text","value":"https://zhuanlan.zhihu.com/p/432927438"}]}]},{"type":"element","tag":"h2","props":{"id":"组件"},"children":[{"type":"text","value":"组件"}]},{"type":"element","tag":"h4","props":{"id":"keep-alive-的理解它是如何实现的具体缓存的是什么"},"children":[{"type":"text","value":"keep-alive 的理解，它是如何实现的，具体缓存的是什么？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"keep-alive 是一个内置抽象组件，会根据内部组件的 key，使用 LRU 策略来缓存组件实例。"}]},{"type":"element","tag":"h4","props":{"id":"vue-的生命周期"},"children":[{"type":"text","value":"Vue 的生命周期"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"keep-alive 独有 activated 和 deactivated 两个生命周期。"}]},{"type":"element","tag":"h4","props":{"id":"vue-子组件和父组件执行顺序"},"children":[{"type":"text","value":"Vue 子组件和父组件执行顺序"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"父组件 mount 前，初始化子组件，所以父组件 beforeMount 后直到子组件 mounted 完成，再挂载。update 和 destroy 两个阶段类似，都是子组件先行。"}]},{"type":"element","tag":"h2","props":{"id":"vue-router"},"children":[{"type":"text","value":"Vue Router"}]},{"type":"element","tag":"h4","props":{"id":"route-vs-router"},"children":[{"type":"text","value":"$route VS $router"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"$route 是路由信息对象，包含 path、params、hash、query 等，$router 是 vue-router 实例，包含路由跳转方法和钩子函数等。"}]},{"type":"element","tag":"h2","props":{"id":"ssr"},"children":[{"type":"text","value":"SSR"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"TODO"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://vuejs.org/guide/scaling-up/ssr.html","rel":["nofollow"]},"children":[{"type":"text","value":"Vue SSR"}]}]},{"type":"element","tag":"h2","props":{"id":"with-typescript"},"children":[{"type":"text","value":"with TypeScript"}]},{"type":"element","tag":"h4","props":{"id":"using-vue-with-typescript"},"children":[{"type":"element","tag":"a","props":{"href":"https://vuejs.org/guide/typescript/overview.html","rel":["nofollow"]},"children":[{"type":"text","value":"Using Vue with TypeScript"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"\"With a Vite-based setup, the dev server and the bundler are transpilation-only and do not perform any type-checking.\""}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Vite-based 的项目不会在开发服务器启用类型检查。Vue 推荐开发者依赖 IDE 进行类型检查，或使用 vue-tsc watch mode、使用 vite-plugin-checker 另起线程插件。Vue 认为类型检查降低开发环境的速度是不值得的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"两个 tsconfig.json 编译选项必须开启：isolatedModule 以便允许 esbuild 解析模块、noImplicitThis 以便启用 this 的类型。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"“but for each project we are running two TS language service instances: one from Volar, one from VSCode's built-in service”"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"禁用 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"@builtin"}]},{"type":"text","value":" TS 插件或打开 Volar 的 Takeover Mode，重启后便能使 Takeover Mode 生效。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"“... with "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"ts-loader"}]},{"type":"text","value":". This, however, isn't a clean solution because the type system needs knowledge of the entire module graph to perform type checks”"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用 loader 用来类型检查的两个缺陷：检测缓慢阻塞编译、只能解析预解析后的文件所以报错不能直接跳转回源码。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"“In version 3.2 and below, the generic type parameter for "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"defineProps()"}]},{"type":"text","value":" were limited to a type literal or a reference to a local interface. This limitation has been resolved in 3.3.”"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"TODO。为什么 Vue 3.2 不能使用外部引入的 Props 作为 type-based defineProps？Vue 3.3 是如何解决的？runtime-declare defineProps 和 runtime-declare emits 会不会对性能有影响？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"“specify a generic type argument but omit the initial value, the resulting type will be a union type that includes "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"undefined"}]},{"type":"text","value":"”"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果不包含初始值，ref 的类型推断会自动包含 undefined。"}]},{"type":"element","tag":"pre","props":{"className":"language-vue shiki shiki-themes material-theme-lighter github-light github-dark monokai","code":"// inferred type: Ref<number | undefined>\nconst n = ref<number>()\n","language":"vue","meta":"","style":""},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"element","tag":"span","props":{"class":"line","line":1},"children":[{"type":"element","tag":"span","props":{"style":"--shiki-light:#90A4AE;--shiki-default:#24292E;--shiki-dark:#E1E4E8;--shiki-sepia:#F8F8F2"},"children":[{"type":"text","value":"// inferred type: Ref"}]},{"type":"element","tag":"span","props":{"style":"--shiki-light:#39ADB5;--shiki-default:#24292E;--shiki-dark:#E1E4E8;--shiki-sepia:#F8F8F2"},"children":[{"type":"text","value":"<"}]},{"type":"element","tag":"span","props":{"style":"--shiki-light:#E53935;--shiki-default:#22863A;--shiki-dark:#85E89D;--shiki-sepia:#F92672"},"children":[{"type":"text","value":"number"}]},{"type":"element","tag":"span","props":{"style":"--shiki-light:#9C3EDA;--shiki-default:#6F42C1;--shiki-dark:#B392F0;--shiki-sepia:#A6E22E"},"children":[{"type":"text","value":" |"}]},{"type":"element","tag":"span","props":{"style":"--shiki-light:#9C3EDA;--shiki-default:#6F42C1;--shiki-dark:#B392F0;--shiki-sepia:#A6E22E"},"children":[{"type":"text","value":" undefined"}]},{"type":"element","tag":"span","props":{"style":"--shiki-light:#39ADB5;--shiki-default:#24292E;--shiki-dark:#E1E4E8;--shiki-sepia:#F8F8F2"},"children":[{"type":"text","value":">\n"}]}]},{"type":"element","tag":"span","props":{"class":"line","line":2},"children":[{"type":"element","tag":"span","props":{"style":"--shiki-light:#90A4AE;--shiki-default:#24292E;--shiki-dark:#E1E4E8;--shiki-sepia:#F8F8F2"},"children":[{"type":"text","value":"const n = ref<number>()\n"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"”Without type annotation, the "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"event"}]},{"type":"text","value":" argument will implicitly have a type of "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"any"}]},{"type":"text","value":". This will also result in a TS error if "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"\"strict\": true"}]},{"type":"text","value":" or "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"\"noImplicitAny\": true"}]},{"type":"text","value":" are used in "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"tsconfig.json"}]},{"type":"text","value":".“"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因为 noImplicitAny 需要打开，不然没法推断 options api 函数中 this 的类型，所以在组件中，接受事件的函数面对 Event 参数必须显式指定类型，不然就会报错。"}]},{"type":"element","tag":"style","props":{},"children":[{"type":"text","value":"html .light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html.light .shiki span {color: var(--shiki-light);background: var(--shiki-light-bg);font-style: var(--shiki-light-font-style);font-weight: var(--shiki-light-font-weight);text-decoration: var(--shiki-light-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}html.sepia .shiki span {color: var(--shiki-sepia);background: var(--shiki-sepia-bg);font-style: var(--shiki-sepia-font-style);font-weight: var(--shiki-sepia-font-weight);text-decoration: var(--shiki-sepia-text-decoration);}"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"todo","depth":2,"text":"TODO"},{"id":"简介","depth":2,"text":"简介"},{"id":"响应式","depth":2,"text":"响应式"},{"id":"模板","depth":2,"text":"模板"},{"id":"编译器","depth":2,"text":"编译器"},{"id":"vdom","depth":2,"text":"VDOM","children":[{"id":"todo-1","depth":3,"text":"TODO"}]},{"id":"组件","depth":2,"text":"组件"},{"id":"vue-router","depth":2,"text":"Vue Router"},{"id":"ssr","depth":2,"text":"SSR"},{"id":"with-typescript","depth":2,"text":"with TypeScript"}]}},"_type":"markdown","_id":"content:6.maps:_framework:ui:vue.md","_source":"content","_file":"6.maps/_framework/ui/vue.md","_stem":"6.maps/_framework/ui/vue","_extension":"md"}