{"_path":"/gists/oo","_dir":"gists","_draft":false,"_partial":false,"_locale":"","title":"OO","description":"面向对象编程","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"uml"},"children":[{"type":"text","value":"UML"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"类之间的关系总的来说可以包含这几种："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"A依赖B：对类B的修改会影响到类A"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"A关联B：对象A知道对象B，类A依赖于类B"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"A聚合B：对象A由B构成，类A依赖于类B"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"A组合B：对象A由B构成且管理B的生命周期，类A依赖于类B"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"A实现B：对象A可视为对象B，类A定义了接口B声明的方法，类A依赖于类B"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"A继承B：对象A可视为对象B，类A继承类B的接口和实现，还可以对其扩展，类A依赖于类B"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Class Relations","src":"https://mgear-image.oss-cn-shanghai.aliyuncs.com/image/other/b3612320-5822-48fc-8041-ead5c269f8e5.svg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Object Relations","src":"https://mgear-image.oss-cn-shanghai.aliyuncs.com/image/other/cff33e77-e9aa-48eb-ae0d-01dd1561abd0.svg"},"children":[]}]},{"type":"element","tag":"h2","props":{"id":"设计原则"},"children":[{"type":"text","value":"设计原则"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"什么是优秀的软件设计？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"显然，在不同的公司、不同的项目，软件设计并没有一个恒定的标准，不过总的来说我们会讨论代码复用以及代码的扩展性。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"有几个基础的设计准则能帮助你做到这两点："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"封装变化：找到程序中易变的内容并将其和不变的内容区分开来"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"面向接口：依赖抽象通常优于依赖具体"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"优先组合：组合优于继承，因为继承有着挺多保守诟病之处"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"SOLID原则"}]}]},{"type":"element","tag":"h3","props":{"id":"组合优于继承"},"children":[{"type":"text","value":"组合优于继承"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"继承通常会引发大量问题："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"子类不能减少父类的接口，并且需要保证兼容"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"继承使状态逃离了父类的封装，子类和父类关系过于紧密"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"继承经常被滥用，导致平行继承体系的出现"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"假设你在售卖一些计算机，这些计算机包含笔记本，台式电脑以及算盘！"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"如果使用继承的思路组织代码，你很可能对得到以下结构："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Computor Structure V1","src":"https://mgear-image.oss-cn-shanghai.aliyuncs.com/image/other/348faf14-874b-410d-b4b9-ff00b04ab14e.svg"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"使用组合可以方便地把不同的“维度”之间的并行关联拆分出来，降低代码复杂度："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Computor Structure V2","src":"https://mgear-image.oss-cn-shanghai.aliyuncs.com/image/other/6cbffe1a-8efd-4de6-9ed3-bfef8392bab5.svg"},"children":[]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"uml","depth":2,"text":"UML"},{"id":"设计原则","depth":2,"text":"设计原则","children":[{"id":"组合优于继承","depth":3,"text":"组合优于继承"}]}]}},"_type":"markdown","_id":"content:7.gists:oo.md","_source":"content","_file":"7.gists/oo.md","_extension":"md"}