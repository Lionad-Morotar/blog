{"_path":"/maps/_source-code/javascript/evil","_dir":"javascript","_draft":false,"_partial":true,"_locale":"","title":"Evil.js","description":"","body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"eviljs"},"children":[{"type":"text","value":"Evil.js"}]},{"type":"element","tag":"h4","props":{"id":"如何阻止类似-eviljs-的投毒"},"children":[{"type":"text","value":"如何阻止类似 evil.js 的投毒？"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用 Function.toString 检测函数是否经过篡改（但是 toString 本身可以被篡改）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用 iFrame 获取相对干净的全局对象（但是 appendChild 和 toString 本身可以被篡改）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用 NodeJS VM 模块获得干净的运行环境"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用 ShadowRealm 获得干净的运行环境"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在代码最上层使用 Object.freeze 冻结全局对象的原型（这会导致依赖改动原型的框架失效，比如 Vue2 修改了数组原型）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在代码最上层缓存原型方法的引用，在使用的时候进行对比"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用万能的 Proxy"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"见："},{"type":"element","tag":"a","props":{"href":"https://www.bilibili.com/video/BV1fe4y1o7kV","rel":["nofollow"]},"children":[{"type":"text","value":"怎么防止 Evil.js 代码投毒"}]}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[]}},"_type":"markdown","_id":"content:6.maps:_source-code:javascript:evil:index.md","_source":"content","_file":"6.maps/_source-code/javascript/evil/index.md","_stem":"6.maps/_source-code/javascript/evil/index","_extension":"md"}