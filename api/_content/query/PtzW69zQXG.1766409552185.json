{"_path":"/maps/_cloud-native/hardware/arm-on-cloud-native","_dir":"hardware","_draft":false,"_partial":true,"_locale":"","title":"Arm 云计算实例 — 建议默认采用","description":"将 Arm 视为云端计算实例的默认选择，除非存在明确的 x86 架构依赖。","body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"brief"},"children":[{"type":"text","value":"Brief"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在主流公有云（AWS、Azure、GCP）中，Arm 架构计算实例因相较传统 x86 实例更具成本和能效优势，已经成为许多场景下的优先选项。我们的多支团队已经在微服务、开源数据库乃至部分高性能计算场景中成功迁移到 Arm，只需少量代码调整和轻微构建脚本修改。新的云上应用和系统也越来越多地直接以 Arm 为默认目标。基于这些经验，我们建议：在不存在特定架构依赖的前提下，大多数工作负载应优先采用 Arm 计算实例。现代工具链（如多架构 Docker 镜像）也进一步简化了在 Arm 与 x86 环境之间的构建与部署。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"来源：技术雷达"}]},{"type":"element","tag":"h2","props":{"id":"details"},"children":[{"type":"text","value":"Details"}]},{"type":"element","tag":"h3","props":{"id":"背景与现状arm-已从尝试选项变成默认选项候选"},"children":[{"type":"text","value":"背景与现状：Arm 已从“尝试选项”变成“默认选项候选”"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"主流云厂商（AWS、Azure、GCP）都已经提供成熟的 Arm 实例家族，并持续迭代。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Arm 在能耗和性价比上的优势，使其对大规模、成本敏感型工作负载尤为有吸引力。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"文本给出的组织内部经验表明：微服务、开源数据库、高性能计算等多类负载已经在 Arm 上稳定运行。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"趋势上，新建云上系统开始“默认跑在 Arm 上”，x86 更像是在有特殊依赖时的例外选择。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对架构与技术负责人而言，这意味着："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"“选 Arm 还是 x86”不再只是底层 Infra 选择，而会反过来影响技术栈、依赖库与第三方组件的选择。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在技术决策模板中，应增加“是否具备 Arm 兼容性”这一项，而不是事后再补。"}]}]},{"type":"element","tag":"h3","props":{"id":"核心模式与技术要点多架构构建与轻量迁移"},"children":[{"type":"text","value":"核心模式与技术要点：多架构构建与轻量迁移"}]},{"type":"element","tag":"h4","props":{"id":"典型工作负载类型"},"children":[{"type":"text","value":"典型工作负载类型"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"基于文中描述和常见实践，Arm 适配良好的类型通常包括："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"容器化微服务：尤其是以 Go/Java/Rust/Node/Python 等为主的 stateless 服务。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"开源数据库与中间件：如常见的关系型数据库、KV/缓存系统，只要官方或社区已提供 arm64 支持。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"批量计算与部分 HPC 工作负载：在编译链支持 Arm 的前提下，往往可以复用绝大部分代码。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这些场景的共同特征是："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"源码可控，或至少可获取源码进行重编译。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"构建与发布已经容器化或自动化，能把“增加一个 arm64 目标”变成流水线配置问题，而不是人工手工活。"}]}]},{"type":"element","tag":"h4","props":{"id":"多架构-docker-镜像与工具链"},"children":[{"type":"text","value":"多架构 Docker 镜像与工具链"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"文中明确提到“多架构 Docker 镜像”作为关键支撑手段，隐含的模式包括："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"构建阶段同时产出 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"linux/amd64"}]},{"type":"text","value":" 与 "},{"type":"element","tag":"code","props":{"className":[]},"children":[{"type":"text","value":"linux/arm64"}]},{"type":"text","value":" 两种镜像，并推送到同一镜像仓库。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"通过 manifest list 让运行时根据节点架构自动拉取对应镜像，减少上层系统感知架构差异的需求。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在 CI/CD 侧通过 matrix / buildx / QEMU 等方式，统一维护一套构建脚本，对两种架构同时生效。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"对团队的启示："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"只要构建链路已经工程化，增加 Arm 支持更多是“一次性工程投入 + 持续的自动化校验”，而不是长期的人力负担。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"与其在项目后期临时“为了省成本”改 Arm，不如在项目早期就把 Arm 纳入 pipeline，以避免后期技术债集中爆发。"}]}]},{"type":"element","tag":"h3","props":{"id":"旧做法-vs-新模式从架构特定到架构无关"},"children":[{"type":"text","value":"旧做法 vs 新模式：从“架构特定”到“架构无关”"}]},{"type":"element","tag":"h4","props":{"id":"传统模式x86-作为默认且唯一的假设"},"children":[{"type":"text","value":"传统模式：x86 作为“默认且唯一”的假设"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"许多老系统在设计和依赖引入时，都默认运行在 x86 服务器上。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"依赖中可能夹杂：只提供 x86 二进制的第三方组件、脚本中写死的 CPU 架构判断、针对特定 SIMD 指令集做的优化等。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在这种前提下，任何非 x86 目标（包括 Arm）都要付出额外适配成本，因此很少在规划阶段被真正考虑。"}]}]},{"type":"element","tag":"h4","props":{"id":"新模式主动追求多架构友好"},"children":[{"type":"text","value":"新模式：主动追求“多架构友好”"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Arm 普及之后，合理的默认心智模型变为："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"业务代码与核心依赖在设计时，优先选择已支持 arm64 的语言运行时与第三方库。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"构建脚本与部署脚本中不再隐含“x86-only”的假设，而是对架构差异进行显式建模（比如通过变量或配置）。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在引入第三方闭源组件时，将“是否支持 arm64”作为评估指标之一。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这种模式的收益："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"架构选择变得更加“可插拔”：相同的应用可以根据成本、性能和容量动态在 x86/Arm 之间迁移或混合部署。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"云资源采购与弹性伸缩策略更灵活，可基于 Spot、预留实例和不同实例族做更精细的成本优化。"}]}]},{"type":"element","tag":"h3","props":{"id":"风险与局限何时不适合把-arm-当成默认"},"children":[{"type":"text","value":"风险与局限：何时不适合把 Arm 当成默认"}]},{"type":"element","tag":"h4","props":{"id":"架构依赖与二进制兼容性"},"children":[{"type":"text","value":"架构依赖与二进制兼容性"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"文中明确给出边界条件：“除非存在特定架构依赖”："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"闭源的 x86-only 组件或 SDK：如只提供 x86 动态库、驱动或 agent。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"强绑定特定 x86 指令集（如 AVX 系列）进行高度手写优化的计算核心，迁移到 Arm 可能需要大量重写与性能再评估。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"某些历史遗留系统中的脚本、配置或运维工具链，可能在架构检测/路径/包名上假定 x86。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"这类场景中，如果要强推 Arm："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"短期成本往往集中在“替换组件 + 深层回归验证”，对稳定性要求高的核心系统风险会比较大。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"对长期收益的判断要更审慎，避免为了一定比例的成本优化，付出不可控的回归与运维代价。"}]}]},{"type":"element","tag":"h4","props":{"id":"生态与工具支持尚不完善的角落"},"children":[{"type":"text","value":"生态与工具支持尚不完善的角落"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"尽管主流语言与工具链已普遍支持 Arm，但在一些边角地带仍需要注意："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"少数原生扩展（Python/Node/Ruby 等）可能缺乏稳定的 arm64 预编译包，导致构建时间增加或偶发编译问题。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"某些监控、APM、安全代理、备份工具在 Arm 上的支持成熟度不一，可能引入观测与安全盲区。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"内部自研的自动化脚本、运维工具（如用于镜像扫描、合规检查等）若写死架构假设，也会成为迁移阻力。"}]}]},{"type":"element","tag":"h3","props":{"id":"系统性影响对架构治理与工程体系的要求"},"children":[{"type":"text","value":"系统性影响：对架构治理与工程体系的要求"}]},{"type":"element","tag":"h4","props":{"id":"对架构一致性与环境抽象的推动"},"children":[{"type":"text","value":"对架构一致性与环境抽象的推动"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"当组织开始大规模使用 Arm："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"会倒逼团队更好地抽象“运行环境”，避免在业务逻辑层出现硬编码的架构假设。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"容器镜像、基础镜像与中间件镜像需要统一管理多架构版本，促进基础设施层做标准化。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"对“环境即代码”（Infra as Code）、自动化测试矩阵、多环境回归提出更高要求。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"长期看，这有助于："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"减少“环境绑定型技术债”，让系统更容易迁移到不同形态的算力资源（例如进一步延伸到边缘计算）。"}]}]},{"type":"element","tag":"h4","props":{"id":"对工程效率与成本治理的拉动"},"children":[{"type":"text","value":"对工程效率与成本治理的拉动"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Arm 的成本与能效优势，会直接影响："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"预算敏感场景（如批处理任务、在线微服务大规模集群）更有动力向 Arm 收敛。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"团队会更频繁地评估“运行在哪类机器上最划算”，而不是仅仅盯着“每个 Pod 的资源 Requests/Limit”。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"前提是："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"指标体系和观测要能清晰分解“架构差异”对性能和成本的影响。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"平台团队需要提供统一的实例选择策略与模板，而不是让每个服务各自为战。"}]}]},{"type":"element","tag":"h3","props":{"id":"落地建议如何在团队内推进arm-优先策略"},"children":[{"type":"text","value":"落地建议：如何在团队内推进“Arm 优先策略”"}]},{"type":"element","tag":"h4","props":{"id":"适用场景与前置条件"},"children":[{"type":"text","value":"适用场景与前置条件"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"更适合优先尝试 Arm 的情形："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"新建服务、对外部二进制依赖较少，或完全基于主流开源栈。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"已经具备成熟的 CI/CD，构建和部署流程标准化，增加一个架构目标代价可控。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"有统一的容器基础镜像和中间件组件仓库，便于集中治理多架构镜像。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不建议贸然切入的情形："}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"核心生产系统依赖大量闭源 x86 组件，且当前对运行时稳定性要求极高。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"团队缺乏自动化回归、性能基准测试与灰度发布能力，难以分阶段评估迁移影响。"}]}]},{"type":"element","tag":"h4","props":{"id":"推进路径与控制风险的方式"},"children":[{"type":"text","value":"推进路径与控制风险的方式"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"一个相对稳健的推进路径可以是："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"从新项目与边缘服务开始"}]}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"新的云上应用默认在 Arm 上规划和验证，构建链路一开始就支持多架构。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"对现有系统，从非核心、流量较小的服务先做试点，建立经验与模板。"}]}]},{"type":"element","tag":"ol","props":{"start":2},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"平台层先把基础设施“铺平”"}]}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"建立统一的多架构基础镜像和中间件镜像仓库。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在 CI/CD 中增加 arm64 构建与测试矩阵，并对关键语言栈做一次性适配。"}]}]},{"type":"element","tag":"ol","props":{"start":3},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"引入观测与基准测试"}]}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"为迁移到 Arm 的服务设计明确的性能基线和回归指标（P99 延迟、吞吐、CPU 利用率、成本等）。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在灰度阶段维持 x86 与 Arm 双跑，通过对比观察性能与稳定性差异。"}]}]},{"type":"element","tag":"ol","props":{"start":4},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"控制范围与节奏"}]}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"使用灰度环境或分批 rollout，将 Arm 迁移与日常功能发布解耦。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"对依赖复杂的系统，先迁移外围组件或只迁移一部分实例比例，保留 x86 作为 fallback。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"通过上述路径，可以在不牺牲稳定性的前提下，逐步把 Arm 从“成本优化选项”升级为“默认架构”，并让架构与工程体系自然适应多架构的长期演进。"}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"brief","depth":2,"text":"Brief"},{"id":"details","depth":2,"text":"Details","children":[{"id":"背景与现状arm-已从尝试选项变成默认选项候选","depth":3,"text":"背景与现状：Arm 已从“尝试选项”变成“默认选项候选”"},{"id":"核心模式与技术要点多架构构建与轻量迁移","depth":3,"text":"核心模式与技术要点：多架构构建与轻量迁移"},{"id":"旧做法-vs-新模式从架构特定到架构无关","depth":3,"text":"旧做法 vs 新模式：从“架构特定”到“架构无关”"},{"id":"风险与局限何时不适合把-arm-当成默认","depth":3,"text":"风险与局限：何时不适合把 Arm 当成默认"},{"id":"系统性影响对架构治理与工程体系的要求","depth":3,"text":"系统性影响：对架构治理与工程体系的要求"},{"id":"落地建议如何在团队内推进arm-优先策略","depth":3,"text":"落地建议：如何在团队内推进“Arm 优先策略”"}]}]}},"_type":"markdown","_id":"content:6.maps:_cloud-native:hardware:arm-on-cloud-native.md","_source":"content","_file":"6.maps/_cloud-native/hardware/arm-on-cloud-native.md","_stem":"6.maps/_cloud-native/hardware/arm-on-cloud-native","_extension":"md"}