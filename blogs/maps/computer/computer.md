# Computer Mind Map

[TOC]

## 进制

#### 十进制如何转二进制？

* 整数除二倒序取余
* 小数乘二顺序取整

#### 十进制转二进制的示例？

以 $(4.1)_{10}$ 为例，先算小数部分，再算整数部分：

1. $0.1\;*\;2\;=\;0.2$，得整数位 $0$，取小数位 $0.2$ 继续运算；
2. $0.2\;*\;2\;=\;0.4$，得整数位 $0$，取小数位 $0.4$ 继续运算；
3. $0.4\;*\;2\;=\;0.8$，得整数位 $0$，取小数位 $0.8$ 继续运算；
4. $0.8\;*\;2\;=\;1.6$，得整数位 $1$，取小数位 $0.6$ 继续运算；
5. $0.6\;*\;2\;=\;1.2$，得整数位 $1$，取小数位 $0.2$ 继续运算（从第二步开始循环）；
6. 得 $(0.1)_{10}$ 转为二进制的结果：$(0.0\overline{0011})_2$
7. $4\;mod\;2 = 0$，得余数 $0$，取结果 $4\;/\;2 = 2$ 继续运算；
8. $2\;mod\;2 = 0$，得余数 $0$，取结果 $2\;/\;2 = 1$ 继续运算；
9. $1\;mod\;2 = 1$，得余数 $1$，结束运算；
10. 得 $(4)_{10}$ 的二进制结果：$(100)_2$
11. 得 $(4.1)_{10}$ 的二进制结果：$(100.0\overline{0011})_2$，可以用 (4.1).toString(2) 验证一下。

## 数字电路

#### 为什么减法要转换为加法的形式？

负数在用原码表示时，需要在最高位带上符号。但是加减乘法作为最基础的运算，其电路应该设计得简单，识别“符号位”会让基础电路变得复杂，所以需要一种算法来把基础运算转换为二进制加法。使用反码计算减法会带来正负零的问题，使用补码则不会发生异常。

#### 什么是原码反码和补码？

* 最高位为符号位,其余为数值位，这是原码
* 正数的反码为其本身，负数的反码为值位取反
* 正数的补码为其本身，负数的补码为其反码加一（符号位不进位）

见：[原码/反码/补码计算器](http://www.atoolbox.net/Tool.php?Id=952)

#### 使用补码进行减法的示例？

以四位整形举例如下，计算表达式 $5 - 2$：

1. 将减法用加法表示为 $5 + (-2)$。
2. $5$ 是正数，直接得补码 $0101$。
3. $-2$ 的原码是 $1010$，数值位取反得 $1101$，最后数值位加一得补码 $1110$。
4. 补码相加，$0101 + 1110$，得 $0011$，换算回十进制，答案是 $3$。

#### 8 位补码的极值是多少？

8 位补码正数的最大值是 $01111111$，即 $(127)_{10}$。因为补码没有负零，所以其负数的最小值为 $-(127 - 1)_{10}$，即 $(-128)_{10}$

## TODO

#### [原码, 反码, 补码详解](https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html)