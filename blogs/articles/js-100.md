# 🏆 学习 JS，从忍者到杀手

<style lang="styl">
label-idx { }
details summary .correct { color: #7ec699; &:before { content: '回答正确：' } }
details summary .wrong { color: #f08d49; &:before { content: '回答错误：' } }
.label-idx { margin-top: 4em;  }

corrects = 'Empty', 'D', 'D', 'C', 'A', 'D', 'B','D', 'A','B','A','C', 'A','D','B','B','C',

len = 16
for i in (1..len) {
    correct = corrects[i]
    #js-100-{i} {
        content: correct;
        details {
          display: none;
        }
        input:checked ~ details  {
          display: block;
          .correct {
      	    display: none;
    	  }
          .wrong {
      	    display: inline;
    	  }
        }
    	input[value=\'{correct}\']:checked ~ details {
          /* summary + p {
            display: none;
          } */
          .correct {
      	    display: inline;
    	  }
          .wrong {
      	    display: none;
    	  }
        }
    }
}
</style>

相信大家对《JS 忍者秘籍》一定非常熟悉。想要成为忍者，必须<del>自宫</del>对原型、闭包、函数、作用域等概念极其熟悉，对各种语言核心概念倒背如流。如果你有幸能将这些原理应用到实战，创建各种精巧的原型，并通过社区的考验，最后才能获得忍者勋章。

不过，杀手和忍者不同，杀手天生就追求每一个细节。确切的说，JS 杀手追求回归 JS 语言本身（而不是编程实践）。

以下，我准备了一些 JS 难题，它们和某些 JS 核心概念相关。每一个 JS 杀手，或者想成为 JS 杀手的开发都可以来试试，看看自己对 JS 的掌握程度。如果回答不出来的话也请不要气馁，因为其中涉及的内容和日常的编程实践相差甚远。

前置说明：

- 代码执行以 ES6 语言规范为标准。
- 每一个代码片段都以全局代码的形式运行。
- 每一个题目都互相独立，其变量互不干涉。

**准备好了吗？杀手试炼开始了！**

<b><span class="label-idx">1.</span>通常，杀手在出门前会先做个热身运动~</b>

```js
do = {
  get exercise() {
    delete do.exercise
    return do.exercise
  }
}
do.exercise
```

<form id="js-100-1" action="" onsubmit="return false">
  <label>请选择答案：</label>
  <input type=radio name=1 value='A'>undefined</input>
  <input type=radio name=1 value='B'>null</input>
  <input type=radio name=1 value='C'>Maxmum call stack size exceeded</input>
  <input type=radio name=1 value='D'>Syntax Error</input>

  <details open>
    <summary><span class='correct'>热身运动完成~</span><span class='wrong'>啊呀，大E了鸭，一不小心扭到腰了！</span></summary>
    <p>`do` 是 JS 中的关键字，一般用在 `do while` 语句中，语法形如：</p>
    <p class='tac'><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-iteration-statements" target="_blank" rel="nofollow"><Math>\mathtt{do} \ Statement_{[?Yield, ?Return]} \ \mathtt{while} ( \ Expression_{[In, ?Yield]} \ ) \ ;</Math></a></p>
    <p>而这个例子里的代码会在静态分析阶段报语法错误“Uncaught SyntaxError: Unexpected token '='”。
      <span class='correct'>保证自始而终的细心是成为杀手的必要素质，你做的很棒！在结束热身之前，也许你想增大一些锻炼强度使自己全面进入状态。请思考，如果把代码中的<code>do</code>全量替换为<code>killer</code>那么会发生什么事儿呢？</span>
    </p>
  </details>
</form>

<b><span class="label-idx">2.</span>出门前别忘了检查一下防弹衣和弹药~</b>

```js
;[Number.isNaN('AKM'), isNaN('7.62 x 39mm BP')]
```

<form id="js-100-2" action="" onsubmit="return false">
  <label>请填写答案：</label>
  <input type=radio name=2 value='A'>true,true</input>
  <input type=radio name=2 value='B'>true,false</input>
  <input type=radio name=2 value='C'>false,false</input>
  <input type=radio name=2 value='D'>false,true</input>

  <details open>
    <summary><span class='correct'>弹药补充完毕！</span><span class='wrong'>居然没弹药！不会吧！？</span></summary>
    <p>总的来说，isNaN 会对传入的值进行 toNumber 转换，而 Number.isNaN 不会。Number.isNaN 是一种比 isNaN 语义更“正确”的版本。具体算法见<a href="https://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan" target="_blank" rel="nofollow">规范</a></p>
    <p class='correct'>背好 AKM，往荷包里塞几个弹匣。万事俱备，准备出发啦！</p>
  </details>
</form>

<b><span class="label-idx">3.</span>插上钥匙，打开车门~</b>

```js
;(function(where, undefined, where) {
  console.log(arguments[1] + where)
})('left', 'sunroof', 'right')
```

<form id="js-100-3" action="" onsubmit="return false">
  <label>请选择答案：</label>
  <input type=radio name=3 value='A'>'rightright'</input>
  <input type=radio name=3 value='B'>'rightleft'</input>
  <input type=radio name=3 value='C'>'sunroofright'</input>
  <input type=radio name=3 value='D'>'sunroofleft'</input>

  <details open>
    <summary><span class='correct'>汽车启动，坐稳了！</span><span class='wrong'>哦？钥匙没拿，还得回去一趟。</span></summary>
    <p>参数类型的绑定行为类似变量声明（VarDeclaration），后绑定的标识符会覆盖先绑定的标识符。此外，<a href="#sec-function-definitions-static-semantics-early-errors" target="_blank" rel="nofollow">规范还提到</a>，只有持有简单参数列表的函数（没有参数默认值）且在非严格模式下运行的代码才支持这种行为。</p>
    <p class='correct'>不管怎么说，你正确启动了汽车，接下来一脚把油门踩到底吧！</p>
  </details>
</form>

<b><span class="label-idx">4.</span>正在加速，坐稳了！</b>

```js
;(function(x = 1, undefined, y = 2) {
  return [...arguments].reduce((speed, acceleration) => speed + acceleration, 0)
})()
```

<form id="js-100-4" action="" onsubmit="return false">
  <label>请选择答案：</label>
  <input type=radio name=4 value='A'>0</input>
  <input type=radio name=4 value='B'>1</input>
  <input type=radio name=4 value='C'>2</input>
  <input type=radio name=4 value='D'>3</input>

  <details open>
    <summary><span class='correct'>时速 80！</span><span class='wrong'>糟糕，发动机好像在冒烟！</span></summary>
    <p>函数实例化时未传入参数，所以 arguments 为空，累加得 0。</p>
    <p class='correct'>时速 80 对专业的杀手——你来说太简单了，也许你在寻求一些额外挑战？请在阅读<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-functiondeclarationinstantiation" target="_blank" rel="nofollow">相关规范</a>后，正确回答以下两行代码运行的结果，这样，你就能斜杠一会儿赛车手~
    <Highlight>
      /* First */
      (function(){ var arguments; console.log(arguments) })();
      /* Second */
      (function(x = 1){ var arguments; console.log(arguments) })();
    </Highlight>
    </p>
  </details>
</form>

<b><span class="label-idx">5.</span>一边开车，一边寻找目标~</b>

```js
;[
  function() {}.__proto__ === Function.prototype,
  Function.prototype === Object.prototype,
  Function.__proto__ === Object.__proto__,
  Function.prototype.__proto__ === Object.prototype
].filter(Boolean).length
```

<form id="js-100-5" action="" onsubmit="return false">
  <label>请选择答案：</label>
  <input type=radio name=5 value='A'>0</input>
  <input type=radio name=5 value='B'>1</input>
  <input type=radio name=5 value='C'>2</input>
  <input type=radio name=5 value='D'>3</input>

  <details open>
    <summary><span class='correct'>哈哈！风景不错~</span><span class='wrong'>糟糕，好像迷路了！</span></summary>
    <p>原型链相关内容是忍者和杀手都要熟练掌握，并刻在脑子里的内容。具体可以康康 <a href="https://www.google.com.hk/search?q=JS+prototype+%2B+Hursh+Jain&tbm=isch&oq=JS+prototype+%2B+Hursh+Jain"  target="_blank" rel="nofollow">Hursh Jain 的 JS 原型链图片</a>，非常清晰，能为你打开新世界的大门。</p>
    <p class='correct'>偶然间，你看到穿黑衣服的目标在巷子门口一闪而过。事不宜迟，赶紧跟上去~</p>
  </details>
</form>

<b><span class="label-idx">6.</span>终于找到目标了！</b>

```js
var target = {
  seen() {
    console.log(this === target)
  }
}
;('haha', target.seen)()
```

<form id="js-100-6" action="" onsubmit="return false">
  <label>请选择答案：</label>
  <input type=radio name=6 value='A'>true</input>
  <input type=radio name=6 value='B'>false</input>
  <input type=radio name=6 value='C'>Error</input>
  <input type=radio name=6 value='D'>undefined</input>

  <details open>
    <summary><span class='correct'>幸亏有了四倍镜~ 你甚至能看清目标脸上的毫毛！</span><span class='wrong'>啊，黑衣服的目标居然消失在了人群中！</span></summary>
    <p><a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-identifiers-runtime-semantics-evaluation" target="_blank" rel="nofollow">规范中提到</a>，对 target.seen 这种标识符，表达式将返回“值”。这个“值”不会携带计算时上下文信息。可以想象为先把 target.seen 赋值给一个变量，然后单独调用该变量，所以 this 指向 window 而不是 target。</p>
    <p class='correct'>定位目标后，你觉得还是应该先破坏掉周围的安保系统为妙。</p>
  </details>
</form>

<b><span class="label-idx">7.</span>破坏警铃~</b>

```js
// 浏览器环境
var alert = (...args) => console.log(args)
delete alert
console.log(window.alert)
```

<form id="js-100-7" action="" onsubmit="return false">
  <label>请选择答案：</label>
  <input type=radio name=7 value='A'>true</input>
  <input type=radio name=7 value='B'>false</input>
  <input type=radio name=7 value='C'>Error</input>
  <input type=radio name=7 value='D'>undefined</input>

  <details open>
    <summary><span class='correct'>正中目标！</span><span class='wrong'>纳尼！？这子弹连摄像头都打不穿？</span></summary>
    <p>在全局代码中声明的变量，分两种情况：一是如果全局对象没有这个属性，就正常走变量声明流程；第二点则比较少的老哥知道了，如果全局对象有这个属性，则通过环境记录（Environment Record，可以理解为引擎提供的用于记录声明的变量这么一个东西）其内部属性 VarNames 将声明的标识符于其值的绑定记录下来。这个记录和正常变量声明不同，是可修改的，可以通过以下代码验证：
    </p>
    <Highlight>
      // 浏览器环境
      var alert = (...args) => console.log(args)
      Object.getOwnPropertyDescriptor(window, 'alert')
      // >>> {writable: true, enumerable: true, configurable: true, value: ƒ}
    </Highlight>
    <p>相关规范有：<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-createglobalvarbinding" target="_blank" rel="nofollow">CreateGlobalVarBinding</a>、<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-delete-operator-runtime-semantics-evaluation" target="_blank" rel="nofollow">Delete Operator</a>。</p>
    <p>多提一句，许多博客说函数的 length 属性具有元属性 DontDelete，DontDelete 为 true，所以不可删除，其实不是这样滴~ 从 ES5 开始 DontDelete 就被内部属性 Configurable 等价替换掉了。从最新的规范中可以找到，<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-functioninitialize" target="_blank" rel="nofollow">函数初始化时</a>，length 属性当前的内部属性 Configurable 实为 true，所以是“可删除的”。你可以打开浏览器控制台，试试创建一个函数，并删除他的 length 属性，就会发现会返回 true。</p>
    <p class='wrong'>想要成为杀手果然一定要先把细节操练一百遍呐！当你准备好了的时候，我们就继续吧。</p>
    <p class='correct'>杀手的世界，容不得半点马虎。看得出来，你是个专业的杀手。</p>
  </details>
</form>

<b><span class="label-idx">8.</span>精确计算开枪距离！</b>

```js
let carX = 1,
  cameraX = 2,
  targetX = 3
console.log(carX < cameraX < targetX, targetX > cameraX > carX)
```

<form id="js-100-8" action="" onsubmit="return false">
  <label>请选择答案：</label>
  <input type=radio name=8 value='A'>true,false</input>
  <input type=radio name=8 value='B'>true,true</input>
  <input type=radio name=8 value='C'>false,false</input>
  <input type=radio name=8 value='D'>Error</input>

  <details open>
    <summary><span class='correct'>目标，锁定~</span><span class='wrong'>风有点大。现在开枪子弹会偏得离谱，再等等吧。</span></summary>
    <p>需要注意两点，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="nofollow">运算符结合性</a>和隐式转换。先计算 1 < 2 为 true，再计算 true < 3 得 true。
    <br />
    和运算符相关的还有一段很经典的代码，据说前些年时，这段代码非常容易出现在面试中：
    </p>
    <Highlight>
      a = {}
      a.x = a = []
      a.x // ?
    </Highlight>
    <p class='correct'>毫无悬念，开枪！</p>
  </details>
</form>

<b><span class="label-idx">9.</span>删除目标！</b>

```js
;[
  void "killer's target" === undefined,
  delete void "killer's target" === delete undefined,
  delete undefined === delete null
].filter(Boolean).length
```

<form id="js-100-9" action="" onsubmit="return false">
  <label>请选择答案：</label>
  <input type=radio name=9 value='A'>0</input>
  <input type=radio name=9 value='B'>1</input>
  <input type=radio name=9 value='C'>2</input>
  <input type=radio name=9 value='D'>3</input>

  <details open>
    <summary><span class='correct'>Target Down！</span><span class='wrong'>我们未能击穿他的装甲（指防弹衣）！</span></summary>
    <p>Void 运算符最后会返回 undefined，所以第一行 true 没跑了。从规范 <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-delete-operator-runtime-semantics-evaluation" target="_blank" rel="nofollow">Delete</a>、<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-undefined" target="_blank" rel="nofollow">Undefined</a> 可以找到，删除 null（值）返回 true，删除 undefined 返回 false，第三行 false 没跑了。难的是第二行：delete undefined 不能直接删除，是因为 delete 运算符会先找到 undefined 的描述符，看到它的内部属性 Configurable 为 false，所以不能删。而 void 'string' 返回的 undefined，却是 undefined 的“值”。听起来有些抽象，我们以以下代码为例：</p>
    <Highlight>
      delete NaN; // false
      +'string'; // NaN
      delete +'string'; // true
    </Highlight>
    <p>NaN 是不可删除的，但是我们的表达式 +'string' 返回的是 NaN 这种“值”，所以 delete +'string' 回退为“删除某个值”这种操作，按照规范直接返回 true。题中的 delete void "killer's target" 与此原理相同，需要先清空一下大脑再去理解。</p>
    <p class='correct'>好，最难的部分解决了！不过按照套路，杀手在第一次行动后，常常因为记起一些不良回忆，陷入恐慌与不安中。接下来，需要你独自面对这种情绪，也就是——你的“心魔”。</p>
  </details>
</form>

<b><span class="label-idx">10.</span>内心的“邪恶”让你眩目！</b>

```js
eval(`typeof typeof ghost === typeof ${typeof ghost}`)
```

<form id="js-100-10" action="" onsubmit="return false">
  <label>请选择答案：</label>
  <input type=radio name=10 value='A'>false</input>
  <input type=radio name=10 value='B'>true</input>
  <input type=radio name=10 value='C'>Error</input>
  <input type=radio name=10 value='D'>undefined</input>

  <details open>
    <summary><span class='correct'>问题不大，问题不大。</span><span class='wrong'>血腥场面使你有些反胃，你看到自己的手莫名地摇摇晃晃。</span></summary>
    <p>typeof 右侧表达式如果是无效引用（不可解决的引用，UnresolvableReference）或是 undefined，都会返回 "undefined"。详见规范：<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-typeof-operator" target="_blank" rel="nofollow">Typeof</a>。不过请注意，这个 "undefined" 是字符串哇~ 模板字符串实例化的结果会变成 “typeof typeof ghost === typeof undefined”，所以结果为 false。</p>
    <p class='correct'>杀手成功战胜了心魔，继续前行~</p>
  </details>
</form>

<b><span class="label-idx">11.</span>又一波“邪恶”😈，它会淹没你吗？</b>

```js
;(function(ghost) {
  const code = `typeof ${ghost}`
  return eval(code) + ('magic', eval)(code)
})('ghost')
```

<form id="js-100-11" action="" onsubmit="return false">
  <label>请选择答案：</label>
  <input type=radio name=11 value='A'>'ghostmagic'</input>
  <input type=radio name=11 value='B'>'undefinedmagic'</input>
  <input type=radio name=11 value='C'>'stringundefined'</input>
  <input type=radio name=11 value='D'>'stringstring'</input>

  <details open>
    <summary><span class='correct'>血腥场面对杀手造成不了任何影响。</span><span class='wrong'>你的精神状态更糟糕了，仿佛看到了目标的幽灵。</span></summary>
    <p>TODO</p>
  </details>
</form>

<b><span class="label-idx">12.</span>SAN 值狂减！</b>

```js
// finally 中的 console.log 会输出么？最后返回的 san 是多少？
;(function() {
  let san = 3
  try {
    --san
    return san
  } finally {
    --san
    console.log(san)
  }
})()
```

<form id="js-100-12" action="" onsubmit="return false">
  <label>请选择答案：</label>
  <input type=radio name=12 value='A'>输出 1，返回 2</input>
  <input type=radio name=12 value='B'>输出 2，返回 1</input>
  <input type=radio name=12 value='C'>输出 1，返回 1</input>
  <input type=radio name=12 value='D'>不输出，返回 2</input>

  <details open> 
    <summary><span class='correct'>对杀手而言，掉一点 SAN 值并不是什么大不了的事情。</span><span class='wrong'>眼前的世界逐渐转为黑白！</span></summary>
    <p>TODO</p>
  </details>
</form>

<b><span class="label-idx">13.</span>快醒醒！千万别大意！</b>

```js
;[
  // Killers have to be careful
  0.1 + 0.2 === 0.3,
  Number.MAX_SAFE_INTEGER === Number.MAX_SAFE_INTEGER + 1
]
```

<form id="js-100-13" action="" onsubmit="return false">
  <label>请选择答案：</label>
  <input type=radio name=13 value='A'>true,true</input>
  <input type=radio name=13 value='B'>true,false</input>
  <input type=radio name=13 value='C'>false,true</input>
  <input type=radio name=13 value='D'>false,false</input>

  <details open> 
    <summary><span class='correct'>显然，杀手也不会过于骄傲大意。</span><span class='wrong'>对面的大楼传来尖叫，有人发现了现场！</span></summary>
    <p>TODO</p>
  </details>
</form>

<b><span class="label-idx">14.</span>打开窗户，把目标绑起来运走！</b>

```js
window.glass = { exist: true }
target = function() {
  return this.exist
}
isExist = target.bind(window.glass)
delete window.glass
console.log(window.glass, isExist())
```

<form id="js-100-14" action="" onsubmit="return false">
  <label>请选择答案：</label>
  <input type=radio name=14 value='A'>undefined,undefined</input>
  <input type=radio name=14 value='B'>undefined,true</input>
  <input type=radio name=14 value='C'>true,true</input>
  <input type=radio name=14 value='D'>Error</input>

  <details open> 
    <summary><span class='correct'>轻而易举~</span><span class='wrong'>乏力使你头晕眼花，完全无法动手！</span></summary>
    <p>TODO</p>
  </details>
</form>

<b><span class="label-idx">15.</span>将行李放到后备箱，回家！</b>

```js
drivetime = 0
isArived = false
console.log('go')
setTimeout(() => (isArived = true), 1000 * 60 * 5 /* 5 minutes */)
while (++drivetime && !isArived) {}
console.log('home')
```

<form id="js-100-2" action="" onsubmit="return false">
  <label>请选择答案：</label>
  <input type=radio name=2 value='A'>'go','home'</input>
  <input type=radio name=2 value='B'>'go'</input>
  <input type=radio name=2 value='C'>'home'</input>
  <input type=radio name=2 value='D'>Empty Log</input>

  <details open> 
    <summary><span class='correct'>钥匙插上，回归 80 迈！</span><span class='wrong'>你靠在行李箱前呼呼喘气，街对面似乎传来警笛声。</span></summary>
    <p>TODO</p>
  </details>
</form>

<b><span class="label-idx">16.</span>开车时请务必确认好方向！</b>

```js
;[
  // Do not turn left or turn right.
  +0 === -0,
  String(+0) === String(-0),
  +0 * 'go home' === -0 * 'go home',
  1 / +0 === 1 / -0
].filter(Boolean).length
```

<form id="js-100-16" action="" onsubmit="return false">
  <label>请选择答案：</label>
  <input type=radio name=16 value='A'>0</input>
  <input type=radio name=16 value='B'>1</input>
  <input type=radio name=16 value='C'>2</input>
  <input type=radio name=16 value='D'>3</input>
  <details open> 
    <summary><span class='correct'>成功逃脱！</span><span class='wrong'>你迷失在了城市中混乱的车流里。</span></summary>
    <p>TODO</p>
  </details>
</form>

## 阅读更多

**wow，不错哟，居然成功从现场撤退了~**

如果你仍意犹未尽，可以试试这些难题（内内，别忘了先给我点赞投币关注三连呐）：

- [Javascript Quiz（2013）](http://perfectionkills.com/javascript-quiz/)
- [Javascript Puzzlers](http://javascript-puzzlers.herokuapp.com/)
