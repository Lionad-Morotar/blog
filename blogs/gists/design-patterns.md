# 设计模式

设计模式可以按照使用方式划分为：创建型模式、结构型模式和行为模式。

* 创建型模式：提供创建对象的机制，增加已有代码的灵活性和可复用性
* 结构性模式：将对象和类组装成更大的结构，保证结构的灵活和高校
* 行为模式：提供对象间的沟通和职责分配  

## 创建型模式

#### 工厂模式

使用工厂模式时，父类提供一个创建对象的方法，允许子类决定实例化对象的具体类型。使用工厂模式可以避免创建者和具体产品之间的紧密耦合，你可以把具体的业务逻辑放到具体创建者中去实现，就算有新的业务逻辑，完全可以使用新的具体创建者去扩展工厂函数。

![[工厂模式结构](https://www.processon.com/diagraming/614ebac1637689481b65eb42)](https://mgear-image.oss-cn-shanghai.aliyuncs.com/image/other/1bcb390f-a1bf-4cb0-8511-de8cecea11ce.svg)

一般来说，由于其复杂性低，工厂函数适合快速设计时使用，随后可以转化为抽象工厂、原型或者生成器模式。

#### 抽象工厂

抽象工厂可以创建一系列相关的对象，而无需指定其具体类，可以将代码和具体创建者（业务逻辑）解耦。

![[抽象工厂结构](https://www.processon.com/diagraming/614ec5dd1efad403f372ff29)](https://mgear-image.oss-cn-shanghai.aliyuncs.com/image/other/a67af4bd-c5ff-472b-a6b4-2c4ea05460d4.svg)

抽象工厂专注于生产一系列对象，举个例子，Weex 和 Web 版本的 ElementUI（假设有的话）就需要根据不同平台去初始化不同的具体工厂实例，再使用具体工厂实例去生成不同的组件。

#### 生成器模式

生成器模式允许使用相同的代码生成不同类型、不同形式的复杂对象，这些复杂对象的构造函数本需要非常多的参数来控制其构造细节，使用生成器模式可以避免这些无止尽的构造函数重载。由于生成器还解耦了构造的步骤，你也许需要一个主管类（Director）来封装这些构造步骤，使其与客户端解耦。

<!-- ProcessOn 生成的 SVG 格式有些问题 -->
![[生成器结构](https://www.processon.com/diagraming/614ed017637689481b66191e)](https://mgear-image.oss-cn-shanghai.aliyuncs.com/image/other/bd255980-5c94-4d8a-8a6f-0b7149ade883.svg)

从图中可以看到当前的主管结构和具体生成器是解耦的，也就是说客户端依赖具体生成器来获取生成结果，这在可能有产品不遵循通用生成器接口的时候有用。

#### 原型模式

原型模式使你能否复制已有对象，而无需依赖它们所属的类。通常，直接遍历并拷贝对象会丢失一些对象私有属性或是外部依赖变量，使用原型模式可以让你更便捷及高效地完成复制操作。直接调用已有对象，以复制一个新对象就像细胞的有丝分裂；你也可以通过提供一个注册表来维护一些基本的可用来复制的预生成对象，并提供搜索方法，方便客户端搜索它们  。

![[原型模式结构](https://www.processon.com/diagraming/614edeb80e3e743114730791)](https://mgear-image.oss-cn-shanghai.aliyuncs.com/image/other/a719383a-7761-4a72-90b9-ac83da7b47d8.svg)

原型模式有一个显著的缺陷便是，克隆包含循环引用的对象会变得非常麻烦。

#### 单例模式

单例模式保证了一个类只有一个对象实例或为访问某实例提供了一个全局节点。使用单例能够方便的控制资源的调度。

![[单例模式结构](https://www.processon.com/diagraming/614ee4e7637689481b664044)](https://mgear-image.oss-cn-shanghai.aliyuncs.com/image/other/42fd4a01-5832-4c43-84c7-fda41402f2d4.svg)




