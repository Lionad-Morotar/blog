# JavaScript 语言精粹与编程实践

## 语法

### 语法综述

语言中的标识符大致分为两类，用于绑定语义逻辑的语法关键字，和用于绑定数据及其存储位置的变量。两者分别限定了逻辑的作用域以及变量的生存周期，所以所谓“声明”，即约定了数据的生存周期以及逻辑的作用域；编程也就被解释成了“说明数据和逻辑”的过程。

可以使用 --check 指令检测语法错误：

```bash
echo '"hello world"' | node -c
```

### 声明语法

JS “识别的” 7 种数据类型叫做基本数据类型（第一类类型），识别是以 typeof 运算符为准的。早期的 JS 语言中，正则是可执行的（实现了 [[call]] 内部方法），所以 typeof 会返回 function，这一 bug 后来被修正。

撇开 OO 不论，JS 中有以下几种类型系统可以讨论：

* 基本数据类型：undefined、string、number、object[^oo]、function、boolean、symbol、bigint
* 值类型和引用类型[^string]

如果算上规范，可以再增加两种类型系统：

* ECMAScript 语言类型：Null、Undefined、String、Symbol、Number、BigInt、Object
* ECMAScript 规范类型：List、Record、Relation、Set、Completion Record、Reference、Property Description、Lexical Environment、Environtment Record，为叙述语言类型提供帮助

[^oo]: 在 ES6 之前，JS 被称为“基于对象语言”，而当其支持 class、super 等关键字后，被称为“支持类继承的面向对象系统”。
[^string]: 在赋值语句中字符串是个例外，按照引用类型处理。

变量声明一共两种形式：显式声明和隐式声明。隐式声明即赋值语句中出现了未声明的变量的情况，这种声明方式不可靠；其余的声明，包括 try...catch 子句中的异常变量都是显式声明。

let 和 var 声明一个不同的地方在于 let 声明不会在全局对象上挂新的属性。

需要注意的是尽管规范确定了常量声明不能再绑定，但是在 ES5 兼容环境或是 ES6 模拟环境中（如使用只读属性模拟常量），修改常量不会抛出异常。

相关字符串字面量的一些冷知识：

* 大于 U+FFFF 的字符的长度在 UTF8 文件夹的长度是 2，但是过换编码，结果不同，试了下 GBK 下的结果为 1。
* 空字符串也能作为对象的键。
* 字符串模板本质上是一个字面量的引用，在 JS 内部表达为一个带 raw 属性的类数组对象，这点可通过 String.raw 函数间接验证。题外话，String.raw 搭配 new RegExp 非常好用哦。

### 表达式运算

运算符不仅是各类标点，还有许多单词，如 typeof、void、new、in、delete、instanceof、yield、await 这些都算。

在规范中经常看到基本表达式（Primary Expression）的概念，它主要由两部分组成：

* 单值表达式：表达式的结果既该值，如 this、super、new.target、arguments 以及各种变量引用以及原始值、正则的字面量
* 非原始值字面量（数组、对象、函数）以及表达式分组运算（()）

可以发现，除了单值表达式外，表达式的结果应该是运算后得到的值（应该至少有一个运算符）。运算符得到的结果类型不外乎值类型、引用类型或 undefined 三种。

ES5 规范了将字符串作为类数组对象，也就是说可以通过下标存取取得字符串的值，但是不能改变它。从 ES6 开始，字符串添加了 Symbol.iterator 属性，可通过展开操作符、yield* 或 for...of 语句操作。

在位运算操作中，运算目标将强制为一个有符号的 32 位整数：非数值转化为数值、浮点数先向零取整，所以常见到“1.1 | 0”这种取证操作并不是位运算有什么魔法，而是在“|0”前，1.1 就被取整了，而任何数按位或 0 会得到其本身。

等值检测的一个缺陷是它不会区分 +0 和 -0，而这两者在数学运算中被认为是两个不同的数；它也不能区分 NaN，所以 ES6 新增了 Object.is 方法来判断 +0、-0 以及 NaN。

```js
Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
```

在比较判定中，JS 总是倾向将操作数转换为数字进行比较，因为字符串比较性能更差。比较运算同理，当字符串和非字符串进行比较时，会尝试将字符串转换为数字。

有一个特例，符号虽然能转化为布尔值，但是不在等值判定算法其中，也就不等值于 true：

```js
Boolean(Symbol()) // true
Symbol() == true // false
```

赋值也是运算符，所以左右两侧都是操作数。按照表达式的概念，操作数可以是值也可以是引用，所以类似“1 = 1”的表达式是可以通过语法检测的，不过只是在其他阶段会抛出引用错误。

```bash
echo "1 = 1" | node -c
```

函数调用也有“隐式调用”这一概念：

* 使用 new 运算符
* 模板处理函数 + 模板字符串调用
* 函数作为属性存取器且发生了属性存取操作时
* 函数作为符号属性（如 Symbol.hasInstance）并触发了对应操作时
* 使用 Proxy 创建了源函数的代理对象后，调用代理对象会隐式调用源函数
* 使用 bind 将源函数绑定为目标函数后，调用目标函数会隐式调用源函数

一直以为使用 bind 时是“创造”了新函数，啊，这里好迷。更迷的是，使用 new 运算符时虽然能见到函数名后面紧跟的小括号，但那不是调用运算符，而是 new 运算符的参数传入表，起调用作用的是 new 运算符，所以是隐式调用。

typeof 在运算符中是一个很特殊的存在，一般变量在表达式中都是以值参与运算，而 typeof 是求值的类型，可以无视标识符是否声明过，比如：

```js
typeof x // undefined
```

但有一个很疑惑的地方是，由于暂时性死区的存在，typeof 运算符也并不总是这么安全。

```js
typeof x // ReferenceError
let x
```

完整的运算符优先级列表如下：

|运算符|描述|
|---|---|
|()|成组运算|
|.、[]、new ()|对象成员存取、数组下标、带传参列表的 new 运算符|
|()、new|函数调用、new 运算符|
|++、--|后置递增、后置递减|
|+、-、++、--、~、!、delete、typeof、void|前置加、前置减、前置递增、前置递减、按位取反、逻辑非、delete、typeof、void|
|*、/、%|乘法、除法、取模|
|+、-、+|加法、减法、字符串连接|
|<<、>>、>>>|移位运算符|
|<、<=、>=、>、in、instanceof|关系运算符、in、instanceof|
|==、!=、===、!==|等值检测|
|&|按位与|
|^|按位异或|
|\||按位或|
|&&|逻辑与|
|\|\||逻辑或|
|?:|三木运算|
|=、oP=|赋值、运算赋值|
|yield、yield*|yield 表达式|
|...|展开运算符|
|，|逗号运算符、多重求值|

### 语句

按照类型，JS 中的语句可分为：声明语句、表达式语句、分支语句、循环语句、控制结构（continue、break 等）、其他（空语句、妇科语句、调式语句）、标签化语句。

需要注意的点：

* 调试语句（debugger;）用于开启宿主环境的调试器
* 除了分号外，EOF 也可以作为语句的结束标志（我没有试验成功）
* 大括号并不是 for...in 等语句的语法元素，但却是 try...catch 中的语法元素

有一段代码没有看懂：

```js
// 为什么能传参到这个匿名函数？void 的运算优先级要比函数调用低来着...
void function (arg) {
  console.log(arg)
}(2)
```

在 for...in 等语句中声明的变量，如果是 var 声明，那么变量作用域将等同于当前所在函数级别，let 及 const 声明则等同于当前语句的块级作用域级别。try...catch 子句中显式声明的变量虽然没有 let、var 等声明关键字，但是经过测试发现其等同于 var 声明。

```js
try { throw 'test' } catch (e) {
  console.log(e); // test
  var e = 1;
}
```

标签不能作用与注释语句，因为注释会被解释器忽略，所以标签作用会渗透到下一个语句；同时他不能作用域导入导出、函数或类声明语句，因为这些语句没有可执行的意义。

continue 子句不允许跳转到“当前/外层的单个循环语句起始”之外的地方，所以在循环语句外面加上花括号是会报语法错误的：

```js
// it works !
test: for (i = 1; i < 3; i++) {
  for (j = 5; j < 8; j++) {
    if (j === 6) continue test;
    else console.log(i, j)
  }
}
// SyntaxError !
test: {
  for (i = 1; i < 3; i++) {
    for (j = 5; j < 8; j++) {
      if (j === 6) continue test;
      else console.log(i, j)
    }
  }
} 
```

ES2019 后，try...catch 允许省略 catch 中的 exception 声明部分。

try...finnally 中的结束处理的执行顺序需要注意，它会在 try 中的 return 后以及 try 中的 break 前执行。

## 勘误？

* P71，属性读取器
* P77，逻辑与、按位非

