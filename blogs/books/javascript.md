# JavaScript 语言精粹与编程实践

## 语法

### 语法综述

语言中的标识符大致分为两类，用于绑定语义逻辑的语法关键字，和用于绑定数据及其存储位置的变量。两者分别限定了逻辑的作用域以及变量的生存周期，所以所谓“声明”，即约定了数据的生存周期以及逻辑的作用域；编程也就被解释成了“说明数据和逻辑”的过程。

可以使用 --check 指令检测语法错误：

```bash
echo '"hello world"' | node -c
```

### 声明语法

JS “识别的” 7 种数据类型叫做基本数据类型（第一类类型），识别是以 typeof 运算符为准的。早期的 JS 语言中，正则是可执行的（实现了 [[call]] 内部方法），所以 typeof 会返回 function，这一 bug 后来被修正。

撇开 OO 不论，JS 中有以下几种类型系统可以讨论：

* 基本数据类型：undefined、string、number、object[^oo]、function、boolean、symbol、bigint
* 值类型和引用类型[^string]

如果算上规范，可以再增加两种类型系统：

* ECMAScript 语言类型：Null、Undefined、String、Symbol、Number、BigInt、Object
* ECMAScript 规范类型：List、Record、Relation、Set、Completion Record、Reference、Property Description、Lexical Environment、Environtment Record，为叙述语言类型提供帮助

[^oo]: 在 ES6 之前，JS 被称为“基于对象语言”，而当其支持 class、super 等关键字后，被称为“支持类继承的面向对象系统”。
[^string]: 在赋值语句中字符串是个例外，按照引用类型处理。

变量声明一共两种形式：显式声明和隐式声明。隐式声明即赋值语句中出现了未声明的变量的情况，这种声明方式不可靠；其余的声明，包括 try...catch 子句中的异常变量都是显式声明。

let 和 var 声明一个不同的地方在于 let 声明不会在全局对象上挂新的属性。

需要注意的是尽管规范确定了常量声明不能再绑定，但是在 ES5 兼容环境或是 ES6 模拟环境中（如使用只读属性模拟常量），修改常量不会抛出异常。

相关字符串字面量的一些冷知识：

* 大于 U+FFFF 的字符的长度在 UTF8 文件夹的长度是 2，但是过换编码，结果不同，试了下 GBK 下的结果为 1。
* 空字符串也能作为对象的键。
* 字符串模板本质上是一个字面量的引用，在 JS 内部表达为一个带 raw 属性的类数组对象，这点可通过 String.raw 函数间接验证。题外话，String.raw 搭配 new RegExp 非常好用哦。

### 表达式运算

运算符不仅是各类标点，还有许多单词，如 typeof、void、new、in、delete、instanceof、yield、await 这些都算。

在规范中经常看到基本表达式（Primary Expression）的概念，它主要由两部分组成：

* 单值表达式：表达式的结果既该值，如 this、super、new.target、arguments 以及各种变量引用以及原始值、正则的字面量
* 非原始值字面量（数组、对象、函数）以及表达式分组运算（()）

可以发现，除了单值表达式外，表达式的结果应该是运算后得到的值（应该至少有一个运算符）。运算符得到的结果类型不外乎值类型、引用类型或 undefined 三种。

ES5 规范了将字符串作为类数组对象，也就是说可以通过下标存取取得字符串的值，但是不能改变它。从 ES6 开始，字符串添加了 Symbol.iterator 属性，可通过展开操作符、yield* 或 for...of 语句操作。

在位运算操作中，运算目标将强制为一个有符号的 32 位整数：非数值转化为数值、浮点数先向零取整，所以常见到“1.1 | 0”这种取证操作并不是位运算有什么魔法，而是在“|0”前，1.1 就被取整了，而任何数按位或 0 会得到其本身。

等值检测的一个缺陷是它不会区分 +0 和 -0，而这两者在数学运算中被认为是两个不同的数；它也不能区分 NaN，所以 ES6 新增了 Object.is 方法来判断 +0、-0 以及 NaN。

```js
Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
```

在比较判定中，JS 总是倾向将操作数转换为数字进行比较，因为字符串比较性能更差。比较运算同理，当字符串和非字符串进行比较时，会尝试将字符串转换为数字。

有一个特例，符号虽然能转化为布尔值，但是不在等值判定算法其中，也就不等值于 true：

```js
Boolean(Symbol()) // true
Symbol() == true // false
```

赋值也是运算符，所以左右两侧都是操作数。按照表达式的概念，操作数可以是值也可以是引用，所以类似“1 = 1”的表达式是可以通过语法检测的，不过只是在其他阶段会抛出引用错误。

```bash
echo "1 = 1" | node -c
```


