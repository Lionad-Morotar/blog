(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{947:function(t,e,r){"use strict";r.r(e);var v=r(0),_=Object(v.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"docker"}},[t._v("Docker")]),t._v(" "),e("nav",{staticClass:"table-of-contents"},[e("ol",[e("li",[e("a",{attrs:{href:"#docker"}},[t._v("Docker")]),e("ol",[e("li",[e("a",{attrs:{href:"#简介"}},[t._v("简介")]),e("ol",[e("li",[e("a",{attrs:{href:"#docker-是什么"}},[t._v("Docker 是什么？")])]),e("li",[e("a",{attrs:{href:"#容器是什么"}},[t._v("容器是什么？")])])])]),e("li",[e("a",{attrs:{href:"#原理"}},[t._v("原理")])]),e("li",[e("a",{attrs:{href:"#概念"}},[t._v("概念")])]),e("li",[e("a",{attrs:{href:"#架构"}},[t._v("架构")])]),e("li",[e("a",{attrs:{href:"#常见指令"}},[t._v("常见指令")])]),e("li",[e("a",{attrs:{href:"#调试流程"}},[t._v("调试流程")])]),e("li",[e("a",{attrs:{href:"#常见问题"}},[t._v("常见问题")])])])])])]),e("h2",{attrs:{id:"简介"}},[t._v("简介")]),t._v(" "),e("h4",{attrs:{id:"docker-是什么"}},[t._v("Docker 是什么？")]),t._v(" "),e("p",[t._v("Docker 本身不是容器，而是容器的一种实现以及容器管理工具。")]),t._v(" "),e("h4",{attrs:{id:"容器是什么"}},[t._v("容器是什么？")]),t._v(" "),e("p",[t._v("容器是一种软件打包的技术。通过对系统资源的控制与隔离，把软件、软件运行时、系统工具、系统库和配置打包到一个镜像中，运行在有有独立命名空间的容器进程内，可以使软件的所有依赖都标准化。所以使用容器技术能方便地将软件打包成标准单元。")]),t._v(" "),e("p",[t._v("TODO")]),t._v(" "),e("h2",{attrs:{id:"原理"}},[t._v("原理")]),t._v(" "),e("p",[t._v("Docker 和虚拟机都希望能提供一个虚拟、完整、独立的运行时环境，通过提高虚拟环境的隔离型，以便管理。一般来说，虚拟机的原理是模拟硬件环境，所以需要安装客户端操作系统"),e("sup",{staticClass:"footnote-ref"},[e("a",{attrs:{href:"#fn1",id:"fnref1"}},[t._v("[1]")])]),t._v("，而 Docker 并不需要这层客户端操作系统，所以 Docker 更加轻量，硬件利用率也更高。")]),t._v(" "),e("p",[t._v("虚拟机使用 Hypervisor 实现操作系统级别的模拟，而 Docker 通过操作系统的文件系统、命名空间、控制组实现进程级别的模拟。")]),t._v(" "),e("p",[t._v("命名空间：所有 Linux 的进程都从 init 进程 fork 派生。Linux 容器的一个主要组件是新的命名空间下的一个 init 进程，所以我们有能力去创建一个不影响外界的进程树出来。")]),t._v(" "),e("p",[t._v("控制组：通过控制组，我们能限制进程对 CPU、磁盘、内存的使用。")]),t._v(" "),e("h2",{attrs:{id:"概念"}},[t._v("概念")]),t._v(" "),e("ol",[e("li",[t._v("隔离环境：虚拟文件系统；POSIX API；文件的只读和屏蔽；命名空间、环境变量等；")]),t._v(" "),e("li",[t._v("生命周期：created、running、pausing、paused、stopped；可以通过 update 动态调整硬件资源使用率")]),t._v(" "),e("li",[t._v("数据卷：数据卷由自己的独立的生命周期")]),t._v(" "),e("li",[t._v("网络：独立的网络命名空间、共享其他实例的网络命名空间、共享主机的网络命名空间")])]),t._v(" "),e("h2",{attrs:{id:"架构"}},[t._v("架构")]),t._v(" "),e("p",[t._v("Docker 引擎实际上由 Dockerd、Containerd、RunC 等组件构成")]),t._v(" "),e("p",[t._v("Dockerd：容器管理 -> 编排管理和集群管理。它接受来自外部的 HTTP 请求并作为 API 调用执行，对内与 Containerd 进行通讯。")]),t._v(" "),e("p",[t._v("Containerd：对镜像、容器的管理提供了一个更进一步的抽象，提供了内容、快照、差异、容器、镜像、任务等更加细粒度的概念。")]),t._v(" "),e("p",[t._v("Container 包含 Containerd-shim，用于正确处理由操作系统发送过来的信号。")]),t._v(" "),e("p",[t._v("RunC：Containerd 提供的容器管理等 API 的执行者是 RunC。")]),t._v(" "),e("h2",{attrs:{id:"常见指令"}},[t._v("常见指令")]),t._v(" "),e("ul",[e("li",[t._v("Build：打包镜像，如 docker build -t test . -f Dockerfile；")]),t._v(" "),e("li",[t._v("Exec：执行容器指令，如 docker exec -it xxx bash；")]),t._v(" "),e("li",[t._v("Run：运行镜像，如 docker run -it test；")]),t._v(" "),e("li",[t._v("Ps：列表，如 docker ps；")]),t._v(" "),e("li",[t._v("Copy：复制文件到 Docker 中，如 docker cp d://test dockerID:dockerPath")])]),t._v(" "),e("h2",{attrs:{id:"调试流程"}},[t._v("调试流程")]),t._v(" "),e("ol",[e("li",[t._v("拉远端镜像：docker pull registry.gitlab.baixing.cn/fenlei/midway-fe:75150")]),t._v(" "),e("li",[t._v("启动容器：docker run -p 8081:7001 -it 5d0c03824600 sleep 999m")]),t._v(" "),e("li",[t._v("进入并调试：docker exec -it name /bin/bash")])]),t._v(" "),e("h2",{attrs:{id:"常见问题"}},[t._v("常见问题")]),t._v(" "),e("p",[t._v("关闭 Hyper-V："),e("code",[t._v("bcdedit /set hypervisorlaunchtype off")])]),t._v(" "),e("hr",{staticClass:"footnotes-sep"}),t._v(" "),e("section",{staticClass:"footnotes"},[e("ol",{staticClass:"footnotes-list"},[e("li",{staticClass:"footnote-item",attrs:{id:"fn1"}},[e("p",[t._v("虚拟机一般有三种模拟方式，裸机型（硬件 + 虚拟 OS + 虚拟 APP）、托管型（OS + Hypervisor + 虚拟 OS + 虚拟 APP）和操作系统虚拟化（OS + 容器 + 虚拟 APP）。 "),e("a",{staticClass:"footnote-backref",attrs:{href:"#fnref1"}},[t._v("↩︎")])])])])])])}),[],!1,null,null,null);e.default=_.exports}}]);