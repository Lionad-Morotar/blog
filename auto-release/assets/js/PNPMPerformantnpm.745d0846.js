(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{990:function(e,t,n){"use strict";n.r(t);var a=n(0),s=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"pnpm-performant-npm"}},[e._v("PNPM（Performant npm）")]),e._v(" "),t("nav",{staticClass:"table-of-contents"},[t("ol",[t("li",[t("a",{attrs:{href:"#pnpm-performant-npm"}},[e._v("PNPM（Performant npm）")]),t("ol",[t("li",[t("a",{attrs:{href:"#api-细节和配置项"}},[e._v("API 细节和配置项")]),t("ol",[t("li",[t("a",{attrs:{href:"#pnpm-import"}},[e._v("pnpm import")])]),t("li",[t("a",{attrs:{href:"#pnpm-fetch"}},[e._v("pnpm fetch")])]),t("li",[t("a",{attrs:{href:"#pnpm-why"}},[e._v("pnpm why")])]),t("li",[t("a",{attrs:{href:"#pnpm-run"}},[e._v("pnpm run")])]),t("li",[t("a",{attrs:{href:"#pnpm-pack"}},[e._v("pnpm pack")])]),t("li",[t("a",{attrs:{href:"#shared-workspace-lockfile"}},[e._v("shared-workspace-lockfile")])]),t("li",[t("a",{attrs:{href:"#-pnpmfile-cjs"}},[e._v(".pnpmfile.cjs")])])])]),t("li",[t("a",{attrs:{href:"#原理"}},[e._v("原理")]),t("ol",[t("li",[t("a",{attrs:{href:"#显著的优点"}},[e._v("显著的优点？")])]),t("li",[t("a",{attrs:{href:"#依赖的层次结构是怎样的"}},[e._v("依赖的层次结构是怎样的？")])]),t("li",[t("a",{attrs:{href:"#如何处理同级依赖"}},[e._v("如何处理同级依赖？")])]),t("li",[t("a",{attrs:{href:"#怎样兼容-nodejs-模块加载顺序"}},[e._v("怎样兼容 NodeJS 模块加载顺序？")])]),t("li",[t("a",{attrs:{href:"#为什么其模块层次只是比较严格的-semistrict-"}},[e._v("为什么其模块层次只是“比较严格的”（semistrict）？")])]),t("li",[t("a",{attrs:{href:"#为什么能节约磁盘空间"}},[e._v("为什么能节约磁盘空间？")])]),t("li",[t("a",{attrs:{href:"#软硬链接有什么问题"}},[e._v("软硬链接有什么问题？")])])])]),t("li",[t("a",{attrs:{href:"#常见问题"}},[e._v("常见问题")]),t("ol",[t("li",[t("a",{attrs:{href:"#pnpm-找不到全局路径的解决方法"}},[e._v("PNPM 找不到全局路径的解决方法？")])])])])])])])]),t("h2",{attrs:{id:"api-细节和配置项"}},[e._v("API 细节和配置项")]),e._v(" "),t("h4",{attrs:{id:"pnpm-import"}},[e._v("pnpm import")]),e._v(" "),t("p",[e._v("使用 "),t("code",[e._v("pnpm import")]),e._v(" 可以将 package-lock、npm-shrinkwrap 和 yarn.lock 转换为 pnpm-lock 文件。")]),e._v(" "),t("h4",{attrs:{id:"pnpm-fetch"}},[e._v("pnpm fetch")]),e._v(" "),t("p",[t("code",[e._v("pnpm fetch")]),e._v(" 它跳过了 package.json 文件，允许项目在只有 pnpm-lock 文件的情况下创建 .pnpm 虚拟仓库。这有利于 docker 构建，因为 package.json 经常因为非依赖变化的改动而改动，导致 docker layer 失效。")]),e._v(" "),t("p",[e._v("相比 yarn 和 npm，在脱离 package.json 的情况下，单靠 package-lock（或 yarn-lock），yarn 和 npm 没有办法确定依赖版本，因为其 package-lock 中，依赖的版本号不是固定版本号。")]),e._v(" "),t("h4",{attrs:{id:"pnpm-why"}},[e._v("pnpm why")]),e._v(" "),t("p",[e._v("使用 "),t("code",[e._v("pnpm why")]),e._v(" 可以列出项目内依赖了某个依赖的依赖，比如说找到项目内使用了 lodash 的包。")]),e._v(" "),t("div",{staticClass:"language-text extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("dependencies:\nelement-plus 2.2.20\n├── lodash 4.17.21\n└─┬ lodash-unified 1.0.3\n  └── lodash 4.17.21 peer\n...\n")])])]),t("h4",{attrs:{id:"pnpm-run"}},[e._v("pnpm run")]),e._v(" "),t("p",[e._v("与其它包管理器的一些区别：")]),e._v(" "),t("ol",[t("li",[t("code",[e._v("pnpm run script-name")]),e._v("，如果 "),t("code",[e._v("script-name")]),e._v(" 没有和 pnpm 内置指令冲突，则可以省略 "),t("code",[e._v("run")])]),e._v(" "),t("li",[e._v("run 指令默认不会执行 pre 和 post 钩子函数，因为 pnpm 认为这使任务流更难理解")]),e._v(" "),t("li",[t("code",[e._v("shell-emulator")]),e._v(" 选项启用后，将使用 JS 解析指令，这使得在不兼容 POSIX 的环境执行类似 "),t("code",[e._v("NODE_ENV=test node ./index")]),e._v(" 的指令会报错的系统也能正常运行这种指令")])]),e._v(" "),t("h4",{attrs:{id:"pnpm-pack"}},[e._v("pnpm pack")]),e._v(" "),t("p",[e._v("将项目打包为 tarball 压缩包（.tgz）。打包的文件范围和 pnpm publish 一样。")]),e._v(" "),t("h4",{attrs:{id:"shared-workspace-lockfile"}},[e._v("shared-workspace-lockfile")]),e._v(" "),t("p",[e._v("在 workspace 间共享一份 package-lock 文件。这个配置开启后，所有子包的依赖都会被提升到 workspace 根目录，这带来了几个好处：")]),e._v(" "),t("ol",[t("li",[e._v("所有依赖都是单例的")]),e._v(" "),t("li",[e._v("更快的安装速度（相比 pnpm install -r）")]),e._v(" "),t("li",[e._v("修改的文件总数更少，利于 Code Review")])]),e._v(" "),t("h4",{attrs:{id:"pnpmfile-cjs"}},[e._v(".pnpmfile.cjs")]),e._v(" "),t("p",[e._v("使用 "),t("code",[e._v(".pnpmfile.cjs")]),e._v(" 文件提供的 readPackge 和 afterAllResolved 钩子函数可以分别介入依赖元信息解析（minifest）和依赖安装完准备输出 lock 文件的过程。")]),e._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("readPackage")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("pkg"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" context")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Override the manifest of foo@1.x after downloading it from the registry")]),e._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("if")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("pkg"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("name "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("===")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[e._v("'foo'")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("&&")]),e._v(" pkg"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("version"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("startsWith")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[e._v("'1.'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Replace bar@x.x.x with bar@2.0.0")]),e._v("\n    pkg"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("dependencies "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n      "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("...")]),e._v("pkg"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("dependencies"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n      "),t("span",{pre:!0,attrs:{class:"token literal-property property"}},[e._v("bar")]),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[e._v("'^2.0.0'")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n    context"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("log")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[e._v("'bar@1 => bar@2 in dependencies of foo'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n  \n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// This will change any packages using baz@x.x.x to use baz@1.2.3")]),e._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("if")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("pkg"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("dependencies"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("baz"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    pkg"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("dependencies"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("baz "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[e._v("'1.2.3'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n  \n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" pkg\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\nmodule"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("exports "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),t("span",{pre:!0,attrs:{class:"token literal-property property"}},[e._v("hooks")]),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    readPackage\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),t("p",[e._v("见："),t("a",{attrs:{href:"https://pnpm.io/pnpmfile",target:"_blank",rel:"noopener noreferrer"}},[e._v("pnpmfile")])]),e._v(" "),t("h2",{attrs:{id:"原理"}},[e._v("原理")]),e._v(" "),t("h4",{attrs:{id:"显著的优点"}},[e._v("显著的优点？")]),e._v(" "),t("ol",[t("li",[e._v("使用软硬链接和符号链接节约空间。")]),e._v(" "),t("li",[e._v("快，因为处理链接要比处理文件快多了，并且每个包的解析、下载和写入磁盘这三个阶段是分离的。")]),e._v(" "),t("li",[e._v("内建支持 monorepo，所有命令支持 "),t("code",[e._v("--filter")]),e._v(" 过滤包。")]),e._v(" "),t("li",[e._v("依赖比较严格，避免幽灵依赖和依赖分身问题。")])]),e._v(" "),t("h4",{attrs:{id:"依赖的层次结构是怎样的"}},[e._v("依赖的层次结构是怎样的？")]),e._v(" "),t("p",[e._v("当项目文件读取 "),t("code",[e._v("bar")]),e._v(" 时，直接读取 "),t("code",[e._v("node_modules/bar")]),e._v("，但它其实是 "),t("code",[e._v(".pnpm")]),e._v(" 文件夹下 "),t("code",[e._v("bar/node_modules/bar")]),e._v(" 的一个符号链接。也就是说，他的真实的地址在 "),t("code",[e._v(".pnpm")]),e._v(" 文件夹下。这样一来，当 "),t("code",[e._v("bar")]),e._v(" 读取它的依赖的时候（项目的依赖的依赖），会在 "),t("code",[e._v("bar")]),e._v(" 的上层目录即 "),t("code",[e._v("bar/node_modules")]),e._v(" 找到 "),t("code",[e._v("foo")]),e._v(" 这个依赖。项目文件没法读取 "),t("code",[e._v("bar/node_modules/foo")]),e._v(" 所以避免了幽灵依赖问题。")]),e._v(" "),t("p",[t("code",[e._v("bar/node_modules/foo")]),e._v(" 要怎么找到它的依赖呢？它的真实地址在项目 ·（和官网的图有出入），所以 foo 也只能读取它自己的子依赖，即 "),t("code",[e._v("node_modules/.pnpm/foo/node_modules")]),e._v("。如果有依赖依赖了同一份（同一版本）的 "),t("code",[e._v("foo")]),e._v("，那么它们的真实地址都是一样的 "),t("code",[e._v("node_modules/.pnpm/foo/node_modules/foo")]),e._v("，这样就避免依赖分身问题。")]),e._v(" "),t("figure",{attrs:{"data-type":"image"}},[t("img",{attrs:{src:"https://mgear-image.oss-cn-shanghai.aliyuncs.com/image/other/20220317192927.png",alt:"",loading:"lazy"}}),t("figcaption",[e._v("Modules Mapping in pnpm")])]),e._v(" "),t("p",[e._v("见："),t("a",{attrs:{href:"https://pnpm.io/blog/2020/05/27/flat-node-modules-is-not-the-only-way",target:"_blank",rel:"noopener noreferrer"}},[e._v("Flat node_modules is not the only way | @pnpm")]),e._v("、"),t("a",{attrs:{href:"https://pnpm.io/symlinked-node-modules-structure",target:"_blank",rel:"noopener noreferrer"}},[e._v("Symlinked node_modules structure | @pnpm")])]),e._v(" "),t("h4",{attrs:{id:"如何处理同级依赖"}},[e._v("如何处理同级依赖？")]),e._v(" "),t("p",[e._v("当项目的两个包 A、B 依赖依赖了同一版本的 C，但是却安装了不同版本的 C 的同级依赖 D@1.0 和 D@1.1，这时，A 依赖的 C 的真实地址是 "),t("code",[e._v(".pnpm/C_D@1.0/node_modules/C")]),e._v("，B 依赖的 C 的真实地址是 "),t("code",[e._v(".pnpm/C_D@1.1/node_modules/C")]),e._v("。这样一来，两个 C 在读取其同级依赖时，分别读取了 "),t("code",[e._v(".pnpm/C_D@1.0/node_modules/D")]),e._v(" 和 "),t("code",[e._v(".pnpm/C_D@1.1/node_modules/D@1.0")]),e._v("，分别对应真实地址 "),t("code",[e._v(".pnpm/D@1.0/node_modules/D")]),e._v(" 和 "),t("code",[e._v(".pnpm/D@1.1/node_modules/D")]),e._v("。")]),e._v(" "),t("p",[e._v("当同级依赖的深度增加时，层级结构也随之变得复杂。如果某个依赖 A 依赖了同一个 B，但是 B 子依赖 C 的版本不同（C@1.0 和 C@1.1），这样就创造出了指数级增长的软链数量。为了保证 B 能分别访问两个 C，B 的符号链接的被链接地址会有 "),t("code",[e._v(".pnpm/B_C@1.0/node_modules/B")]),e._v(" 和 "),t("code",[e._v(".pnpm/B_C@1.1/node_modules/B")]),e._v("，而为此，A 的被链接地址也会有两个，"),t("code",[e._v(".pnpm/A_C@1.0/node_modules/A")]),e._v(" 和 "),t("code",[e._v(".pnpm/A_C@1.0/node_modules/A")]),e._v("。从不同的 A 的被链接地址的上级目录 "),t("code",[e._v("node_modules")]),e._v(" 可以读取到不同的 B 的被链目录，从不同的 B 可以读取到不同的 C。")]),e._v(" "),t("div",{staticClass:"language-text extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("node_modules\n└── .pnpm\n    ├── a@1.0.0_c@1.0.0\n    │   └── node_modules\n    │       ├── a\n    │       └── b -> ../../b@1.0.0_c@1.0.0/node_modules/b\n    ├── a@1.0.0_c@1.1.0\n    │   └── node_modules\n    │       ├── a\n    │       └── b -> ../../b@1.0.0_c@1.1.0/node_modules/b\n    ├── b@1.0.0_c@1.0.0\n    │   └── node_modules\n    │       ├── b\n    │       └── c -> ../../c@1.0.0/node_modules/c\n    ├── b@1.0.0_c@1.1.0\n    │   └── node_modules\n    │       ├── b\n    │       └── c -> ../../c@1.1.0/node_modules/c\n    ├── c@1.0.0\n    ├── c@1.1.0\n")])])]),t("p",[e._v("见："),t("a",{attrs:{href:"https://pnpm.io/how-peers-are-resolved",target:"_blank",rel:"noopener noreferrer"}},[e._v("How peers are resolved | @pnpm")])]),e._v(" "),t("h4",{attrs:{id:"怎样兼容-nodejs-模块加载顺序"}},[e._v("怎样兼容 NodeJS 模块加载顺序？")]),e._v(" "),t("p",[e._v("不论系统自带的模块，NodeJS 加载模块的顺序是这样的：")]),e._v(" "),t("ol",[t("li",[e._v("读取本文件夹中 node_modules 中对应名字的文件夹的 package.json，并寻找 main 字段对应的路径")]),e._v(" "),t("li",[e._v("读取本文件夹中 node_modules 中对应名字的 js 文件")]),e._v(" "),t("li",[e._v("读取本文件夹中 node_modules 中对应名字文件夹中的 index.js 文件")]),e._v(" "),t("li",[e._v("跳出本文件夹，继续前三个步骤")])]),e._v(" "),t("p",[e._v("因为项目 "),t("code",[e._v("node_modules/bar")]),e._v(" 是 "),t("code",[e._v(".pnpm/bar/node_modules/bar")]),e._v(" 的符号链接，所以项目文件可以直接读取 "),t("code",[e._v("node_modules/bar/x.js")]),e._v("。同时，如果 "),t("code",[e._v("node_modules/bar/x.js")]),e._v(" 需要加载 "),t("code",[e._v("foo/x.js")]),e._v("，那么在上述步骤的第 4 步，就能找到 "),t("code",[e._v(".pnpm/bar/node_modules/foo/x.js")]),e._v(" 文件。")]),e._v(" "),t("h4",{attrs:{id:"为什么其模块层次只是-比较严格的-semistrict"}},[e._v("为什么其模块层次只是“比较严格的”（semistrict）？")]),e._v(" "),t("p",[e._v("由 NodeJS 模块加载规则可知，在 pnpm 创造的依赖层次下，一个依赖的子依赖间仍有相互访问的能力。")]),e._v(" "),t("h4",{attrs:{id:"为什么能节约磁盘空间"}},[e._v("为什么能节约磁盘空间？")]),e._v(" "),t("p",[e._v("由 pnpm 创造的 node_modules 层级结构可以知道，所有依赖的符号链接的真实地址都在 "),t("code",[e._v(".pnpm/package-name/node_modules/package-name")]),e._v(" 这个文件夹中。这种文件夹会通过硬链接的形式链接到 "),t("code",[e._v("user-document/.pnpm-store")]),e._v(" 中，所以相同的包只会存一份，也就是 "),t("code",[e._v(".pnpm-store/package-name")]),e._v("。")]),e._v(" "),t("h4",{attrs:{id:"软硬链接有什么问题"}},[e._v("软硬链接有什么问题？")]),e._v(" "),t("ul",[t("li",[e._v("特定的软链结构会导致某些应用出现死循环")]),e._v(" "),t("li",[e._v("硬链接是同一份文件，不便调试")]),e._v(" "),t("li",[e._v("软链接在非 SSD 上的读写会有性能损耗")]),e._v(" "),t("li",[e._v("pnpm 创造的 node_modules 层级结构会破坏某些依赖依赖了相对路径的依赖的逻辑")])]),e._v(" "),t("p",[e._v("见："),t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/553804414",target:"_blank",rel:"noopener noreferrer"}},[e._v("精读 pnpm")])]),e._v(" "),t("h2",{attrs:{id:"常见问题"}},[e._v("常见问题")]),e._v(" "),t("h4",{attrs:{id:"pnpm-找不到全局路径的解决方法"}},[e._v("PNPM 找不到全局路径的解决方法？")]),e._v(" "),t("p",[e._v("尽管设置了全局变量，也重新安装了最新版本 PNPM，也执行了 pnpm setup，却仍然报错找不到全局路径的临时解决方案：")]),e._v(" "),t("div",{staticClass:"language-powershell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-powershell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token variable"}},[e._v("$PNPM_HOME")]),e._v("="),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"<path>"')]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" pnpm install "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("-")]),e._v("g xxx\n")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);