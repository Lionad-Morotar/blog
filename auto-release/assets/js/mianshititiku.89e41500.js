(window.webpackJsonp=window.webpackJsonp||[]).push([[180],{359:function(n,e,t){},456:function(n,e,t){"use strict";t(359)},957:function(n,e,t){"use strict";t.r(e);t(456);var a=t(0),r=Object(a.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"面试题题库"}},[n._v("面试题题库")]),n._v(" "),e("nav",{staticClass:"table-of-contents"},[e("ol",[e("li",[e("a",{attrs:{href:"#面试题题库"}},[n._v("面试题题库")]),e("ol",[e("li",[e("a",{attrs:{href:"#算法题"}},[n._v("算法题")]),e("ol",[e("li",[e("a",{attrs:{href:"#简单-斐波那契数列"}},[n._v("简单-斐波那契数列")])]),e("li",[e("a",{attrs:{href:"#简单-合并有序链表"}},[n._v("简单-合并有序链表")])]),e("li",[e("a",{attrs:{href:"#简单-反转链表"}},[n._v("简单-反转链表")])]),e("li",[e("a",{attrs:{href:"#中等-有效的括号字符串"}},[n._v("中等-有效的括号字符串")])]),e("li",[e("a",{attrs:{href:"#中等-数组第k个最大元素"}},[n._v("中等-数组第K个最大元素")])]),e("li",[e("a",{attrs:{href:"#中等-二叉树的层序遍历"}},[n._v("中等-二叉树的层序遍历")])])])]),e("li",[e("a",{attrs:{href:"#编程题"}},[n._v("编程题")]),e("ol",[e("li",[e("a",{attrs:{href:"#简单-bind"}},[n._v("简单-bind")])]),e("li",[e("a",{attrs:{href:"#中等-instanceof"}},[n._v("中等-instanceof")])]),e("li",[e("a",{attrs:{href:"#中等-深拷贝函数"}},[n._v("中等-深拷贝函数")])]),e("li",[e("a",{attrs:{href:"#中等-柯里化函数"}},[n._v("中等-柯里化函数")])]),e("li",[e("a",{attrs:{href:"#中等-列表数据转树结构"}},[n._v("中等-列表数据转树结构")])]),e("li",[e("a",{attrs:{href:"#中等-promise-mapseries"}},[n._v("中等-Promise.mapSeries")])])])]),e("li",[e("a",{attrs:{href:"#综合题"}},[n._v("综合题")]),e("ol",[e("li",[e("a",{attrs:{href:"#简单-统计当前页面用到的所有html标签的种类"}},[n._v("简单-统计当前页面用到的所有HTML标签的种类")])]),e("li",[e("a",{attrs:{href:"#中等-商品排序"}},[n._v("中等-商品排序")])]),e("li",[e("a",{attrs:{href:"#困难-给定以下递归函数提问"}},[n._v("困难-给定以下递归函数提问")])]),e("li",[e("a",{attrs:{href:"#困难-商品全排列"}},[n._v("困难-商品全排列")])])])]),e("li",[e("a",{attrs:{href:"#类型编程"}},[n._v("类型编程")]),e("ol",[e("li",[e("a",{attrs:{href:"#简单-omit"}},[n._v("简单-Omit")])]),e("li",[e("a",{attrs:{href:"#简单-trim"}},[n._v("简单-Trim")])]),e("li",[e("a",{attrs:{href:"#中等-deepreadonly"}},[n._v("中等-DeepReadonly")])])])])])])])]),e("h2",{attrs:{id:"算法题"}},[n._v("算法题")]),n._v(" "),e("h4",{attrs:{id:"简单-斐波那契数列"}},[e("a",{attrs:{href:"https://leetcode.cn/problems/fibonacci-number/",target:"_blank",rel:"noopener noreferrer"}},[n._v("简单-斐波那契数列")])]),n._v(" "),e("p",[n._v("斐波那契数列指以 0、1、1、2、3、5、8... 之后每一项都是前面两项数字之和这种规律排列的数组。给定 n，计算数列第 n 项的值。")]),n._v(" "),e("p",[n._v("后续提问方向：")]),n._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://leetcode.cn/problems/fibonacci-number/solution/fei-bo-na-qi-shu-by-leetcode-solution-o4ze/#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92",target:"_blank",rel:"noopener noreferrer"}},[n._v("简单-非递归解法（递推）")])]),n._v(" "),e("li",[n._v("简单-时间复杂度最小的解法（枚举）")])]),n._v(" "),e("h4",{attrs:{id:"简单-合并有序链表"}},[e("a",{attrs:{href:"https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/",target:"_blank",rel:"noopener noreferrer"}},[n._v("简单-合并有序链表")])]),n._v(" "),e("p",[n._v("输入两个有序的链表的头节点，返回合并好的链表的头节点。如输入 1->2->4 和 1->3->4，输出 1->1->2->3->4->4")]),n._v(" "),e("p",[n._v("后续提问方向：")]),n._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/solution/he-bing-liang-ge-pai-xu-de-lian-biao-by-g3z6g/#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E8%BF%AD%E4%BB%A3",target:"_blank",rel:"noopener noreferrer"}},[n._v("简单-空间复杂度最小的解法（迭代）")])])]),n._v(" "),e("h4",{attrs:{id:"简单-反转链表"}},[e("a",{attrs:{href:"https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/submissions/",target:"_blank",rel:"noopener noreferrer"}},[n._v("简单-反转链表")])]),n._v(" "),e("p",[n._v("输入一个链表的头节点，输出该链表反转后的头节点。如输入 1->2->3，输出 3->2->1")]),n._v(" "),e("p",[n._v("后续提问方向：")]),n._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/solution/fan-zhuan-lian-biao-by-leetcode-solution-jvs5/#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E8%BF%AD%E4%BB%A3",target:"_blank",rel:"noopener noreferrer"}},[n._v("简单-空间复杂度最小的解法（迭代）")])]),n._v(" "),e("li",[n._v("中等-环形链表或包含环的链表的反转")])]),n._v(" "),e("h4",{attrs:{id:"中等-有效的括号字符串"}},[e("a",{attrs:{href:"https://leetcode.cn/problems/valid-parenthesis-string/",target:"_blank",rel:"noopener noreferrer"}},[n._v("中等-有效的括号字符串")])]),n._v(" "),e("p",[n._v("给定由 '('、')'、两种字符的字符串，验证左右括号是否配对。")]),n._v(" "),e("ul",[e("li",[n._v('")(()))"          =>  false')]),n._v(" "),e("li",[n._v('"(())((()())())"  =>  true')])]),n._v(" "),e("p",[n._v("后续提问方向：")]),n._v(" "),e("ul",[e("li",[n._v('困难-增加星号字符，"*"，可作为单个左括号或单个右括号或空字符串使用，测试用例“(((((())*)))()))(()((*()*(*)))(*)()”')])]),n._v(" "),e("h4",{attrs:{id:"中等-数组第k个最大元素"}},[e("a",{attrs:{href:"https://leetcode.cn/problems/kth-largest-element-in-an-array/",target:"_blank",rel:"noopener noreferrer"}},[n._v("中等-数组第K个最大元素")])]),n._v(" "),e("p",[n._v("给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。")]),n._v(" "),e("p",[n._v("后续提问方向：")]),n._v(" "),e("ul",[e("li",[n._v("困难-使用时间复杂度为 O(n) 的解法。")])]),n._v(" "),e("h4",{attrs:{id:"中等-二叉树的层序遍历"}},[e("a",{attrs:{href:"https://leetcode.cn/problems/binary-tree-level-order-traversal/",target:"_blank",rel:"noopener noreferrer"}},[n._v("中等-二叉树的层序遍历")])]),n._v(" "),e("p",[n._v("给定二叉树的根节点 root，返回树的层序遍历的结果。")]),n._v(" "),e("figure",{attrs:{"data-type":"image"}},[e("img",{attrs:{src:"https://mgear-image.oss-cn-shanghai.aliyuncs.com/image/other/20220812013637.png",alt:"",loading:"lazy"}})]),n._v(" "),e("p",[n._v("输入：如上图所示。输出：[[3],[9,20],[15,7]]")]),n._v(" "),e("h2",{attrs:{id:"编程题"}},[n._v("编程题")]),n._v(" "),e("h4",{attrs:{id:"简单-bind"}},[n._v("简单-bind")]),n._v(" "),e("details",[e("summary",[n._v("用例")]),n._v(" "),e("Highlight",[n._v("\n    const a = {\n      name: 'a',\n      say() {\n        console.log(this.name)\n      },\n    }\n    const c = {\n      name: 'c',\n    }\n    a.say.bind(c)() // \"c\"\n  ")])],1),n._v(" "),e("details",[e("summary",[n._v("参考实现")]),n._v(" "),e("Highlight",[n._v("\n    Function.prototype.bind = function bind(context = globalThis) {\n      const fn = this\n      context.fn = fn\n      return (...args) => {\n        const res = context.fn(...args)\n        delete context.fn\n        return res\n      }\n    }\n  ")])],1),n._v(" "),e("h4",{attrs:{id:"中等-instanceof"}},[n._v("中等-instanceof")]),n._v(" "),e("p",[n._v("instanceof 运算符先通过检测类的 Symbol.hasInstance 来判断对象是否是类实例，如果没有相应方法则检测构造器的原型在不在对象的原型链上。")]),n._v(" "),e("details",[e("summary",[n._v("参考实现")]),n._v(" "),e("Highlight",[n._v("\n    function _instanceof (val, fn) {\n      const hasInstance = fn[Symbol.hasInstance]\n      if (hasInstance) {\n        return fn[Symbol.hasInstance](val)\n      }\n      const proto = fn.prototype\n      while ((val = Object.getPrototypeOf(val))) {\n        if (val === proto) {\n          return true\n        }\n      }\n      return false\n    }\n  ")])],1),n._v(" "),e("p",[n._v("后续提问方向：")]),n._v(" "),e("ul",[e("li",[n._v("困难-有哪些判断类型的方法？各有什么优缺点？")]),n._v(" "),e("li",[n._v("偏门-创造一个类 God 使得 "),e("code",[n._v("null instanceof God")]),n._v(" 为真")])]),n._v(" "),e("h4",{attrs:{id:"中等-深拷贝函数"}},[n._v("中等-深拷贝函数")]),n._v(" "),e("details",[e("summary",[n._v("参考实现")]),n._v(" "),e("Highlight",[n._v("\n    function cloneDeep (obj) {\n      if (typeof obj !== 'object') {\n        return obj\n      }\n      if (obj instanceof Array) {\n        return obj.map(cloneDeep)\n      }\n      return Object.entries(obj).reduce((h, [k, v]) => {\n        h[k] = cloneDeep(v)\n        return h\n      }, {})\n    }\n  ")])],1),n._v(" "),e("p",[n._v("后续提问方向：")]),n._v(" "),e("ul",[e("li",[n._v("中等-如何支持多种类型，如 Function、Symbol、Undefined、RegExp、Math")]),n._v(" "),e("li",[n._v("中等-如何处理对象间循环引用")])]),n._v(" "),e("h4",{attrs:{id:"中等-柯里化函数"}},[n._v("中等-柯里化函数")]),n._v(" "),e("details",[e("summary",[n._v("用例")]),n._v(" "),e("Highlight",[n._v("\n    const add = curry(function (a, b) {  return a + b })\n    const add5 = add(5)\n    add5(6) // 11\n  ")])],1),n._v(" "),e("details",[e("summary",[n._v("参考实现")]),n._v(" "),e("Highlight",[n._v("\n    const curry = (fn, ...args) => {\n      if (args.length >= fn.length) {\n        return fn.apply(null, args)\n      } else {\n        const newFn = (...extraArgs) => curry(fn, ...args, ...extraArgs)\n        Object.defineProperty(newFn, 'length', { value: fn.length - args.length })\n        return newFn\n      }\n    }\n  ")])],1),n._v(" "),e("h4",{attrs:{id:"中等-列表数据转树结构"}},[n._v("中等-列表数据转树结构")]),n._v(" "),e("details",[e("summary",[n._v("用例")]),n._v(" "),e("Highlight",[n._v('\n    // 输入\n    [\n      {\n        id: "1",\n        name: "page",\n      },\n      {\n        name: "page-name",\n        id: "2",\n        parent: "1",\n      },\n      {\n        name: "text",\n        id: "3",\n        parent: "2",\n      },\n      {\n        name: "text",\n        id: "4",\n        parent: "2",\n      }\n    ]\n    // 输出\n    [\n      {\n        "id": "1",\n        "name": "page",\n        "components": [\n          {\n            "name": "page-name",\n            "id": "2",\n            "parent": "1",\n            "components": [\n              {\n                "name": "text",\n                "id": "3",\n                "parent": "2",\n              },\n              {\n                "name": "text",\n                "id": "4",\n                "parent": "2",\n              }\n            ]\n          }\n        ]\n      }\n    ]\n  ')])],1),n._v(" "),e("details",[e("summary",[n._v("参考实现")]),n._v(" "),e("Highlight",[n._v("\n    function toTree (data) {\n      data = data || []\n      const map = {}\n      const roots = []\n      data.map(x => map[x.id] = x)\n      data.map(x => {\n        if (map[x.parent]) {\n          map[x.parent].components = map[x.parent].components || []\n          map[x.parent].components.push(x)\n        } else {\n          roots.push(x)\n        }\n      })\n      return roots\n    }\n  ")])],1),n._v(" "),e("h4",{attrs:{id:"中等-promise-mapseries"}},[e("a",{attrs:{href:"http://bluebirdjs.com/docs/api/promise.mapseries.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("中等-Promise.mapSeries")])]),n._v(" "),e("details",[e("summary",[n._v("用例")]),n._v(" "),e("Highlight",[n._v('\n  const fileNames = ["1.txt", Promise.resolve("2.txt"), "3.txt"]\n  Promise.mapSeries(fileNames, function(fileName, index, arrayLength) {\n      return fs.readFileAsync(fileName).then(function() {\n          return fileName + "!"\n      });\n  }).then(function(result) {\n      console.log(result)\n      // ["1.txt!", "2.txt!", "3.txt!"]\n  })\n  ')])],1),n._v(" "),e("details",[e("summary",[n._v("参考实现")]),n._v(" "),e("Highlight",[n._v("\n    Promise.mapSeries = (arr, fn) => {\n      if (!Array.isArray(arr)) {\n        throw new TypeError(`Promise.mapSeries requires array, but got ${typeof arr}`)\n      }\n      return new Promise(async (resolve) => {\n        const results = []\n        for (let i = 0; i < arr.length; i++) {\n          const val = await Promise.resolve(arr[i])\n          results[i] = await fn(val, i, arr.length)\n        }\n        resolve(results)\n      })\n    }\n  ")])],1),n._v(" "),e("p",[n._v("后续提问方向：")]),n._v(" "),e("ul",[e("li",[n._v("困难-给实现加上类型（TypeScript）")])]),n._v(" "),e("h2",{attrs:{id:"综合题"}},[n._v("综合题")]),n._v(" "),e("h4",{attrs:{id:"简单-统计当前页面用到的所有html标签的种类"}},[n._v("简单-统计当前页面用到的所有HTML标签的种类")]),n._v(" "),e("details",[e("summary",[n._v("参考实现")]),n._v(" "),e("Highlight",[n._v("\n    [...new Set([...document.querySelectorAll('*')].map(x => x.tagName))]\n    // ['HTML', 'DIV', 'SPAN', ...]\n  ")])],1),n._v(" "),e("h4",{attrs:{id:"中等-商品排序"}},[n._v("中等-商品排序")]),n._v(" "),e("p",[n._v("设计一个支持扩展的排序函数。使得给定的食物列表按照价格升序、评分降序的顺序排列。")]),n._v(" "),e("details",[e("summary",[n._v("用例")]),n._v(" "),e("Highlight",[n._v('\n    const food = [\n      { name: "Suger", price: 1, rating: 3 },\n      { name: "Chocolate", price: 3, rating: 4 },\n      { name: "Burger", price: 3, rating: 2 },\n      { name: "Cola", price: 1, rating: 5 },\n      { name: "Pizza", price: 5, rating: 3 },\n    ]\n    food.sort(yourSortFunction)\n    // [{"name": "Cola","price": 1,"rating": 5},\n    //  {"name": "Suger","price": 1,"rating": 3},\n    //  {"name": "Chocolate","price": 3,"rating": 4},\n    //  {"name": "Burger","price": 3,"rating": 2},\n    //  {"name": "Pizza","price": 5,"rating": 3}]\n  ')])],1),n._v(" "),e("details",[e("summary",[n._v("参考实现")]),n._v(" "),e("Highlight",[n._v("\n    const sort = map => compareFn => (a, b) => compareFn(map(a), map(b))\n    const flipComparison = fn => (a, b) => -fn(a, b)\n    const byValue = (a, b) => a - b\n    const byPrice = sort(e => e.price)(byValue)\n    const byRating = sort(e => e.rating)(flipComparison(byValue))\n    const sortFlattend = sortFns => (a, b) => sortFns.reduce((sortResult, fn) => sortResult || fn(a,b), 0)\n    const byPriceThenRating = sortFlattend([byPrice, byRating])\n    // food.sort(byPriceThenRating)\n  ")])],1),n._v(" "),e("h4",{attrs:{id:"困难-给定以下递归函数提问"}},[n._v("困难-给定以下递归函数提问")]),n._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("function")]),n._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[n._v("recur")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),e("span",{pre:!0,attrs:{class:"token parameter"}},[n._v("n")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("if")]),n._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("n "),e("span",{pre:!0,attrs:{class:"token operator"}},[n._v("===")]),n._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[n._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v(" console"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[n._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("else")]),n._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[n._v("recur")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),n._v("n "),e("span",{pre:!0,attrs:{class:"token operator"}},[n._v("-")]),n._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[n._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[n._v("recur")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[n._v("500000")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v(")")]),n._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[n._v("// >>> RangeError: Maximum call stack size exceeded")]),n._v("\n")])])]),e("ul",[e("li",[n._v("简单-将该函数转换为循环的写法避免栈溢出")]),n._v(" "),e("li",[n._v("困难-使用任意循环以外的方法改写函数避免栈溢出")])]),n._v(" "),e("details",[e("summary",[n._v("参考实现")]),n._v(" "),e("Highlight",[n._v("\n    function recur(n) {\n      if (n === 0) console.log(n)\n      else return () => recur(n - 1)\n    }\n    function trampoline(fn) {\n      let res = () => fn()\n      while (res instanceof Function) {\n          res = res()\n      }\n      return res\n    }\n    trampoline(recur(50000000)) // 0\n  ")])],1),n._v(" "),e("h4",{attrs:{id:"困难-商品全排列"}},[n._v("困难-商品全排列")]),n._v(" "),e("p",[n._v("任意技术栈。给定商品的规格信息以及库存列表，实现商品的全排列表格。表格行首有 checkbox，表格能多选，但如果库存中没有此行的商品规格则此行不能被选中。")]),n._v(" "),e("details",[e("summary",[n._v("基础代码及用例")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://mgear-image.oss-cn-shanghai.aliyuncs.com/image/other/20220812105700.png"}}),n._v("\n    代码地址："),e("a",{attrs:{href:"https://element-plus.run/#eyJBcHAudnVlIjoiPHRlbXBsYXRlPlxuICA8ZWwtdGFibGUgOmRhdGE9XCJ0YWJsZURhdGFcIiBzdHlsZT1cIndpZHRoOiAxMDAlXCI+XG4gICAgPGVsLXRhYmxlLWNvbHVtbiB0eXBlPVwic2VsZWN0aW9uXCIgd2lkdGg9XCI1NVwiIC8+XG4gICAgPGVsLXRhYmxlLWNvbHVtbiBwcm9wPVwibmFtZVwiIGxhYmVsPVwi5ZCN56ewXCIgd2lkdGg9XCIxODBcIiAvPlxuICAgIDxlbC10YWJsZS1jb2x1bW4gcHJvcD1cImNvbG9yXCIgbGFiZWw9XCLpopzoibJcIiAvPlxuICAgIDxlbC10YWJsZS1jb2x1bW4gcHJvcD1cInNhbGVzZXRcIiBsYWJlbD1cIuWll+mkkFwiIC8+XG4gICAgPGVsLXRhYmxlLWNvbHVtbiBwcm9wPVwic2l6ZVwiIGxhYmVsPVwi5YaF5a2YXCIgLz5cbiAgPC9lbC10YWJsZT5cbjwvdGVtcGxhdGU+XG48c2NyaXB0IGxhbmc9XCJ0c1wiIHNldHVwPlxuICAvLyDllYblk4HlsZ7mgKfmmI7nu4ZcbiAgY29uc3Qgc3BlY0xpc3QgPSBbXG4gICAgeyB0aXRsZTogXCLpopzoibJcIiwga2V5OiAnY29sb3InLCBsaXN0OiBbXCLnuqLoibJcIiwgXCLntKvoibJcIiwgXCLnmb3oibJcIiwgXCLpu5HoibJcIl0gfSxcbiAgICB7IHRpdGxlOiBcIuWll+mkkFwiLCBrZXk6ICdzYWxlc2V0JywgbGlzdDogW1wi5aWX6aSQ5LiAXCIsIFwi5aWX6aSQ5LqMXCIsIFwi5aWX6aSQ5LiJXCJdIH0sXG4gICAgeyB0aXRsZTogXCLlhoXlrZhcIiwga2V5OiAnc2l6ZScsIGxpc3Q6IFtcIjY0R1wiLCBcIjEyOEdcIiwgXCIyNTZHXCJdIH1cbiAgXVxuICAvLyDliankvZnlupPlrZjliJfooahcbiAgY29uc3Qgc3RvcmFnZSA9IFtcbiAgICB7IGlkOiBcIjFcIiwgc3BlY3M6IFtcIue0q+iJslwiLCBcIuWll+mkkOS4gFwiLCBcIjY0R1wiXSB9LFxuICAgIHsgaWQ6IFwiMlwiLCBzcGVjczogW1wi57Sr6ImyXCIsIFwi5aWX6aSQ5LiAXCIsIFwiMTI4R1wiXSB9LFxuICAgIHsgaWQ6IFwiM1wiLCBzcGVjczogW1wi57Sr6ImyXCIsIFwi5aWX6aSQ5LqMXCIsIFwiMTI4R1wiXSB9LFxuICAgIHsgaWQ6IFwiNFwiLCBzcGVjczogW1wi6buR6ImyXCIsIFwi5aWX6aSQ5LiJXCIsIFwiMjU2R1wiXSB9XG4gIF1cbiAgY29uc3QgdGFibGVEYXRhID0gW11cbjwvc2NyaXB0PlxuIiwiaW1wb3J0X21hcC5qc29uIjoie1xuICBcImltcG9ydHNcIjoge31cbn0iLCJfbyI6e319",rel:"noopener noreferrer",target:"_blank"}},[n._v("Element Plus Playground")])])]),n._v(" "),e("h2",{attrs:{id:"类型编程"}},[n._v("类型编程")]),n._v(" "),e("h4",{attrs:{id:"简单-omit"}},[n._v("简单-Omit")]),n._v(" "),e("details",[e("summary",[n._v("用例")]),n._v(" "),e("Highlight",[n._v("\n    interface Todo {\n      title: string\n      description: string\n      completed: boolean\n    }\n    type TodoPreview = MyOmit<Todo, 'description' | 'title'>\n    const todo: TodoPreview = {\n      completed: false,\n    }\n  ")])],1),n._v(" "),e("details",[e("summary",[n._v("参考实现")]),n._v(" "),e("Highlight",[n._v("\n    type MyOmit<T, K extends keyof T> = {\n      [P in Exclude<keyof T, K>]: T[P]\n    }\n  ")])],1),n._v(" "),e("h4",{attrs:{id:"简单-trim"}},[n._v("简单-Trim")]),n._v(" "),e("details",[e("summary",[n._v("用例")]),n._v(" "),e("Highlight",[n._v("\n    // trimed expected to be 'Hello World'\n    type trimed = Trim<'  Hello World  '>\n  ")])],1),n._v(" "),e("details",[e("summary",[n._v("参考实现")]),n._v(" "),e("Highlight",[n._v("\n    type Trim<S extends string> = S extends\n      | `${' ' | '\\t' | '\\n'}${infer Rest}`\n      | `${infer Rest}${' ' | '\\t' | '\\n'}`\n      ? Trim<Rest>\n      : S\n  ")])],1),n._v(" "),e("h4",{attrs:{id:"中等-deepreadonly"}},[n._v("中等-DeepReadonly")]),n._v(" "),e("details",[e("summary",[n._v("用例")]),n._v(" "),e("Highlight",[n._v("\n    type X = { \n      x: { \n        a: 1\n        b: 'hi'\n      }\n      y: 'hey'\n    }\n    type Expected = { \n      readonly x: { \n        readonly a: 1\n        readonly b: 'hi'\n      }\n      readonly y: 'hey' \n    }\n    type Todo = DeepReadonly<X> // should be same as `Expected`\n  ")])],1),n._v(" "),e("details",[e("summary",[n._v("参考实现")]),n._v(" "),e("Highlight",[n._v("\n    type DeepReadonly<T extends any> = {\n      readonly [P in keyof T]: T[P] extends (...args: any[]) => any\n        ? T[P]\n        : DeepReadonly<T[P]>\n    }\n  ")])],1)])}),[],!1,null,null,null);e.default=r.exports}}]);